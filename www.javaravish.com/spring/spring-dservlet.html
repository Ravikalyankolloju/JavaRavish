<!DOCTYPE html>
<html lang="en">
<meta http-equiv="content-type" content="text/html;charset=UTF-8" />

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="author" content="Java By Ravi Kalyan">

	<title>Java Ravish | Spring Introduction</title>

	<link rel="shortcut icon" type="image/x-icon" href="../scripts/images/favicon/android-chrome-192x192.png" />
	<link rel="apple-touch-icon" href="../scripts/images/favicon/apple-touch-icon.jpeg">
	<link href="../scripts/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="../scripts/css/customcss.css">

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js"></script>
	<style>
		.div-to-hide {
			display: block;
			/* Display the div by default */
		}

		@media screen and (max-width: 767px) {
			.div-to-hide {
				display: none;
				/* Hide the div on screens smaller than 768px (mobile) */
			}
		}
	</style>
</head>

<body>
	<nav class="navbar navbar-expand-lg border-bottom navbarmenu fixed-top bg-white">
		<div class="container p-0">
			<a class="navbar-brand pull-left" href="../main/home.html"><img src="../scripts/images/jrlogo.PNG"
					style="height: 50px; max-width: 100%;" alt="java by Kalyan" title="Java Ravish Tutorials"></a>
			<button class="w3-button w3-teal w3-hide-large" type="button" data-toggle="collapse"
				data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
				&#9776;
			</button>
			<div class="collapse navbar-collapse pull-right" id="navbarResponsive">
				<ul class="navbar-nav ml-auto text-center">
					<li class="nav-item"><a class="nav-link" href="../main/home.html"><img
								src="../scripts/images/small/home.jpg"></i></a>
					</li>
					<li class="nav-item"><a class="nav-link" href="../corejava/java-introduction.html">Java</a></li>
					<li class="nav-item"><a class="nav-link" href="../spring/spring-introduction.html">Spring</a></li>
					<li class="nav-item"><a class="nav-link" href="../springboot/sb-introduction.html">SpringBoot</a>
					</li>
					<li class="nav-item"><a class="nav-link" href="../main/interview-questions.html">Interview
							Questions</a></li>

				</ul>
			</div>
		</div>
	</nav>
	<br>
	<div class="container-fluid">
		<br />
		<ol class="breadcrumb no-padding  mt-5 bg-light nohighlight">
			<li itemprop="itemListElement" class="breadcrumb-item">
				<a class="text-dark" itemprop="item" href="../main/home.html"> <span itemprop="name">Home</span></a>
				<meta itemprop="position" content="1" />
			</li>
			<li itemprop="itemListElement" class="breadcrumb-item">
				<a class="text-dark" itemprop="item" href="spring-introduction.html"> <span
						itemprop="name">Spring</span>
				</a>
				<meta itemprop="position" content="2" />
			</li>
			<li itemprop="itemListElement" class="breadcrumb-item">
				<a class="text-dark" itemprop="item" href="#">
					<span itemprop="name">Spring Introduction</span>
				</a>
			</li>
		</ol>

		<div class="row">
			<link rel="stylesheet" href="../scripts/css/sidebarcollapsecss.css">
			<button class="w3-button w3-teal w3-hide-large" type="button" data-toggle="collapse"
				data-target="#sideBarResponsive" aria-controls="sideBarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
				&#9776;
			</button>
			<div class="col-lg-3 w3-collapse w3-animate-right hidesidebar sidebarfont" id="mySidebar" role="tablist"
				aria-multiselectable="true">
				<div class="collapse card" id="sideBarResponsive">
					<h2 class="card-header text-white" style="background: rgb(0,0,0);">Spring</h2>
					<div class="list-group">
						<ul class="leftBarList">
							<li><a href="../spring/spring-introduction.html">Introduction</a></li>
							<li><a href="../spring/spring-ioc.html">Inversion Of Control</a></li>
							<li><a href="../spring/spring-aop.html">Aspect Oriented Programming</a></li>
							<li><a href="../spring/spring-point.html">Pointcut and Advisors</a>
							</li>
							<li><a href="../spring/spring-aop-2.0.html">Spring 2.0 AOP Support</a></li>
							<li><a href="../spring/spring-jdbc.html">JDBC and DAO Module</a></li>
							<li><a href="../spring/spring-hibernate.html">Hibernate</a></li>
							<li><a href="../spring/spring-persistent.html">Persistent Classes Mapping</a></li>
							<li><a href="../spring/spring-hql.html">HQL and Criterion
									API</a></li>
							<li><a href="../spring/spring-hibernate-integration.html">Hibernate with Spring</a></li>
							<li><a href="../spring/spring-mvc.html">MVC Introduction</a></li>
							<li><a href="../spring/spring-mvc-fw.html">MVC Framework</a></li>

							<li><a href="../spring/spring-dservlet.html">DispatcherServlet</a>
							</li>
							<li><a href="../spring/spring-controller.html">Controllers and Validations</a>
							</li>
							<li><a href="../spring/spring-view.html">View-Resolver and View</a></li>
							<li><a href="../spring/spring-jms.html">Implementing JMS using Spring</a></li>
						</ul>
					</div>
				</div>
				<div class="div-to-hide card" id="sideBarResponsive">
					<h2 class="card-header text-white" style="background: rgb(0,0,0);">Spring</h2>
					<div class="list-group">
						<ul class="leftBarList">
							<li><a href="../spring/spring-introduction.html">Introduction</a></li>
							<li><a href="../spring/spring-ioc.html">Inversion Of Control</a></li>
							<li><a href="../spring/spring-aop.html">Aspect Oriented Programming</a></li>
							<li><a href="../spring/spring-point.html">Pointcut and Advisors</a>
							</li>
							<li><a href="../spring/spring-aop-2.0.html">Spring 2.0 AOP Support</a></li>
							<li><a href="../spring/spring-jdbc.html">JDBC and DAO Module</a></li>
							<li><a href="../spring/spring-hibernate.html">Hibernate</a></li>
							<li><a href="../spring/spring-persistent.html">Persistent Classes Mapping</a></li>
							<li><a href="../spring/spring-hql.html">HQL and Criterion
									API</a></li>
							<li><a href="../spring/spring-hibernate-integration.html">Hibernate with Spring</a></li>
							<li><a href="../spring/spring-mvc.html">MVC Introduction</a></li>
							<li><a href="../spring/spring-mvc-fw.html">MVC Framework</a></li>

							<li><a href="../spring/spring-dservlet.html">DispatcherServlet</a>
							</li>
							<li><a href="../spring/spring-controller.html">Controllers and Validations</a>
							</li>
							<li><a href="../spring/spring-view.html">View-Resolver and View</a></li>
							<li><a href="../spring/spring-jms.html">Implementing JMS using Spring</a></li>
						</ul>
					</div>
				</div>
			</div>
			<div class="col-lg-9 mb-4">
				<div class="card h-100">
					<h1 class="card-header text-white" style="background: rgb(0,0,0);">Spring Introduction</h1>
					<div class="card-body">
						<div class="tab" role="tabpanel">
							<ol type="I">
								<li><a href="#DispatcherServlet">DispatcherServlet </a>
									<ul>
										<li><a href="#Initialization-Parameters">Initialization Parameters of
												DispatcherServlet </a></li>
										<li><a href="#Initialization-Stage">DispatcherServlet Initialization Stage </a>
										</li>
										<li><a href="#special-objects">Spring WEB MVC Framework special objects </a>
										</li>
									</ul>
								</li>
								<li><a href="#Request-Processing-Work-flow">Spring WEB MVC Request Processing Work flow
										(Phases : 8) </a>
									<ol>

										<li><a href="#Prepare-the-request-context">Prepare the request context </a></li>

										<li><a href="#Locate-The-Handler">Locate The Handler </a>
											<ul>

												<li><a href="#HandlerMappings">HandlerMappings </a>
													<ol type="i">
														<li><a href="#BeanNameUrlHandlerMapping">BeanNameUrlHandlerMapping
															</a></li>
														<li><a href="#SimpleUrlHandlerMapping">SimpleUrlHandlerMapping
															</a></li>
														<li><a href="#ControllerClassNameHandlerMapping">ControllerClassNameHandlerMapping
															</a></li>
														<li><a href="#CommonsPathMapHandlerMapping">CommonsPathMapHandlerMapping
															</a> </li>
													</ol>
												</li>

												<li><a href="#multiple-handler-mappings">Configuring multiple handler
														mappings </a></li>
											</ul>
										</li>

										<li><a href="#preHandle-methods">Execute Interceptors preHandle methods </a>
											<ul>

												<li><a href="#HandlerInterceptor">Using HandlerInterceptor </a></li>
											</ul>
										</li>

										<li><a href="#Invoke-Handler">Invoke Handler </a>
											<ul>

												<li><a href="#HandlerAdapter">HandlerAdapter </a>
													<ol type="i">
														<li><a
																href="#SimpleControllerHandlerAdapter">SimpleControllerHandlerAdapter</a>
														</li>
														<li><a href="#ThrowawayControllerHandlerAdapter">ThrowawayControllerHandlerAdapter
															</a></li>
														<li><a href="#HttpRequestHandlerAdapter">HttpRequestHandlerAdapter
															</a></li>
														<li><a href="#SimpleServletHandlerAdapter">SimpleServletHandlerAdapter
															</a></li>
													</ol>
												</li>

												<li><a href="#ModelAndView">ModelAndView </a></li>
											</ul>
										</li>

										<li><a href="#postHandle-methods">Execute Interceptors postHandle methods </a>
										</li>
										<li><a href="#Handle-Exceptions">Handle Exceptions </a></li>

										<li><a href="#Render-the-View">Render the View </a>
											<ul>
												<li><a href="#Resolve-View-Name">The 'Resolve View Name' process </a>
												</li>
											</ul>
										</li>

										<li><a href="#afterCompletion-methods">Execute Interceptors afterCompletion
												methods </a></li>
									</ol>
								</li>
							</ol>

							<h6 id="DispatcherServlet">DispatcherServlet :</h6>
							<ul>
								<li>The DispatcherServlet of Spring Web MVC framework is an implementation of
									FrontController and is a Java Servlet component. i.e., it is a servlet front for
									spring Web Mvc application.</li>
								<li>DispathcherServlet is the FrontController classes that receives all incoming HTTP
									client request for the spring Web mvc appliaction.</li>
								<li>DispatcherServlet is responsible for initializing spring web mvc framework for our
									application, and is a servlet implemented as a sub-type of HttpServlet just like any
									other Servlet.</li>
								<li>DispatcherServlet also required to be configured in our web-application like any
									other Servlet i.e., web application deployment descriptor(web.xml)</li>
							</ul>

							DispatcherServlet
							<pre>&lt;servlet&gt;
&lt;servlet-name&gt;ds&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</pre>

							<p>We can configure the initialization parameters to alter the behavior of the
								DispatcherServlet with respect to locating the spring Beans XML configuration files and
								initializing the application context. </p>


							<h6 id="Initialization-Parameters">Initialization Parameters of DispatcherServlet :</h6>
							<ol>
								<li><strong>contextClass : </strong> </li>
								<li><strong>namespace : </strong> </li>
								<li><strong>contextConfigLocation : </strong> </li>
								<li><strong>publishContext : </strong> </li>
								<li><strong>publishEvents : </strong> </li>
								<li><strong>detectAllHandlerMappings : </strong> </li>
								<li><strong>detectAllHandlerAdapters : </strong> </li>
								<li><strong>detectAllHandlerExceptionResolvers : </strong> </li>
								<li><strong>detectAllViewResolvers : </strong> </li>
								<li><strong>cleanupAfterInclude : </strong> </li>
							</ol>


							<pre>&lt;servlet&gt;

&lt;servlet-name&gt;ds&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;

&lt;init-param&gt;
 &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
 &lt;param-value&gt;
  /WEB-INF/applicationContext.xml
  /WEB-INF/myconfigs/applicationControllers.xml
 &lt;/param-value&gt;
&lt;/init-param&gt;

&lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</pre>




							<pre>&lt;servlet-mapping&gt;
&lt;servlet-name&gt;ds&lt;/servlet-name&gt;
&lt;url-pattern&gt;*.spring&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>

							<ul>
								<li>All the request for this context whose servletPath ends with
									<strong>.spring</strong> extension are displayed by the web container to the
									DispatcherServlet.</li>
								<li>It is not mandatory to configure only .spring, instead of configure any other
									extension.</li>
							</ul>

							<p>Spring Web MVC framework does not force to use specific extensions or patterns in
								URL's;<br>
								Spring frame work is not bonded to match the handlers only based on URLs.Alternatively
								we can define a mapping based on parameters or HTTPSession state etc., <br> This future
								is not supported by most of Web MVC framework which includes Struts.</p>



							<h3 id="Initialization-Stage">DispatcherServlet Initialization Stage :</h3>
							<ul>
								<li>While initializing the DispatcherServlet it creates WebApplicationContext
									implementing class instance, either user configured custom context class (or) the
									default XmlWebApplicationContext.</li>
								<li>The WebApplicationContext is responsible to locate the Spring Beans XML
									configuration file, then read, validate the configurations and load the details into
									configuration objects.</li>
								<li>The DispatcherServlet uses the WebApplicationContext for accessing various framework
									objects that are used to execute the WebApplicationContext.</li>
							</ul>
							<h6 id="special-objects">Spring WEB MVC Framework special objects :</h6>
							<ol>
								<li>MultipartResolver</li>
								<li>LocaleResolver</li>
								<li>ThemeResolver</li>
								<li>HandlerMapping</li>
								<li>HandlerAdapter</li>
								<li>HandlerExceptionResolver</li>
								<li>RequestToViewNameTranslator</li>
								<li>ViewResolver</li>
							</ol>

							<ul>
								<li>All the special frame work objects initialized by the DispatcherServlet using the
									WebApplicationContext and based on the detectAllXXX initialization parameters
									configured to this servlet.</li>
								<li>Once if all these objects are initialized successfully, the DispatcherServlet
									instance is put into service, which provides an entry point to serve the client
									requests using the special frame work objects.</li>
							</ul>




							<h2 id="Request-Processing-Work-flow">Spring WEB MVC Request Processing Work flow :</h2>

							<ul>
								<li>According to spring MVC , DispatcherServlet is the front controller for the spring
									Web MVC application, providing a centralized access for various requests to the
									application and collaborating with various other objects to complete the request
									handling and present the response to client.</li>
								<li>DispatcherServlet uses the WebApplicationContext object to locate the various
									objects configured in the Spring Bean XML configuration file.</li>
								<li>The WebApplicationContext is instantiated and initialized as a part of the
									DispatcherServlet's initialization process.</li>
								<li>The WebApplicationContext object is responsible to locate the spring beans XML
									configuration file and load its details to prepare the context for handling the
									requests.</li>

							</ul>


							<img alt="" src="mvc/mvc.png">
							<br><br>
							<p>Now, when a client request is given to DispatcherServlet, it performs the following
								operations:</p>

							Types of Phases :
							<ol>
								<li><a href="#Prepare-the-request-context">Prepare the request context </a> </li>
								<li><a href="#Locate-The-Handler">Locate The Handler </a> </li>
								<li><a href="#preHandle-methods">Execute Interceptors preHandle methods </a> </li>
								<li><a href="#Invoke-Handler"> Invoke Handler</a> </li>
								<li><a href="#postHandle-methods">Execute Interceptors postHandle methods </a> </li>
								<li><a href="#Handle-Exceptions"> Handle Exceptions </a> </li>
								<li><a href="#Render-the-View">Render the View </a> </li>
								<li><a href="#afterCompletion-methods"> Execute Interceptors afterCompletion methods
									</a> </li>
							</ol>


							<img alt="springFlow" src="mvc/springFlow.png" height="540px" width="650px"><br>

							<h3 id="Prepare-the-request-context">Phase 1 : Prepare the request context </h3>
							<ol>
								<li>DispatcherServlet prepare the request context, by setting the framework objects into
									the request scope. </li>
								<li> Here framework objects are WebApplicationContext, LocaleResolver, ThemeResolver and
									ThemeSource.</li>
								<li> These objects are set into the request scope to make them available to handler and
									view objects.<br>
									so that the handler or view objects can use these objects to communicate with the
									framework and collect runtime details. </li>
								<li>Apart from preparing and setting the framework objects into the request scope,
									DispatcherServlet resolves the request using MultipartResolver , so that if the
									request contains contains multi part data , then it wraps the request in a
									MultipartHttpRequest type object.</li>
								<li>In case , if there is any problem in this process the request processing is
									terminated by throwing an Exception.</li>
								<li>Once if this process is done successfully the request process workflow continues to
									the next phase, i.e., Locate the Handler.</li>
							</ol>


							<h3 id="Locate-The-Handler">Phase 2 : Locate The Handler </h3>

							<img alt="" src="mvc/springPhase2.png" height="540px" width="650px">

							<ol>
								<li>After preparing the request context , the DispatcherServlet locates handler that can
									handle this request.</li>
								<li>The DispatcherServlet uses the registered HandlerMapping's and collects the
									HandlerExecutionChain object.</li>
								<li>The HandlerExecutionChain object encapsulates the HandlerIntercepter's and the
									Handler object (i.e., controller).</li>
								<li>Preparing an Iterator object of the Collection, storing the HandlerMapping objects.
								</li>
								<li>This Collection object is created while the DispatcherServlet is being initialized,
									i.e., in its initialization phase.</li>
								<li>Thereafter, the first element is received from the iterator. This can't be an empty
									collection since if there is no HandlerMapping configured in the context the
									DispatcherServlet uses BeanNameUrlHandlerMapping as default HandlerMapping. </li>

								<li>Invoke the getHandler() of the current HandlerMapping object in the iteration.
									<ul>
										<li> If getHandler() returns null, get the next element is available the next
											HandlerMapping. Otherwise set response error code(i.e.,
											HttpServletResponse_SC_NOT_FOUND) and terminate request processing. </li>
										<li>If getHandler() returns a valid HandlerExecutionChain object reference then
											the control delegates to next phase.(i.e., Execute Interceptors preHandle
											methods ) </li>
									</ul>
								</li>
							</ol>

							<h5 id="HandlerMappings">The HandlerMappings :</h5>
							<ol>
								<li>The HandlerMapping is responsible for mapping the incoming request to the handler
									that can handle the request.</li>
								<li>As discussed in the above section, When the DispatcherServlet receives the request
									it delegates the request to the HandlerMapping, which identifies the appropriate
									HandlerExecutionChain that can handle the request.</li>
								<li>The Spring Web MVC framework provides customizable navigation strategies. Spring
									provides built-in navigation strategies as determining the handler based on the
									request URL mapping , which is again based on the bean name.</li>
								<li>A part from the built-in navigation strategies, Spring allows system-specific built
									strategy, which can be done by writing a class implementing the HandlerMapping
									interface.</li>

							</ol>
							The Spring built-in HandlerMapping implementations are :
							<ol>
								<li>BeanNameUrlHandlerMapping</li>
								<li>SimpleUrlHandlerMapping</li>
								<li>ControllerClassNameHandlerMapping</li>
								<li>CommonsPathMapHandlerMapping</li>
							</ol>

							<h5 id="BeanNameUrlHandlerMapping">BeanNameUrlHandlerMapping</h5>

							<ul>
								<li>The
									<strong>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</strong>
									is one of the implementation of HandlerMapping interface.</li>
								<li>This implementation defines the navigation strategy that maps the request URL's
									servlet-path to the bean names.</li>
								<li>This handler mapping strategy is very simple but powerful.</li>
							</ul>
							<p>The BeanNameUrlHandlerMapping is the default handler mapping when no handler mapping is
								configured in the application context.</p>
							<b>The BeanNameUrlHandlerMapping explicitly configure in 2 cases :</b>
							<ol>
								<li>When we want to configure multiple handler mapping </li>
								<li>When we want to configure handler interceptors </li>
							</ol>




							ds-servlet.xml
							<pre> &lt;beans&gt;
 
 &lt;bean id="handlerMapping" 
 class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;

&lt;bean name="/addEmployee.spring" class="com.spring.AddEmployeeController"&gt;
 &lt;!-- set the dependencies --&gt;
&lt;/bean&gt;

&lt;bean name="/removeEmployee.spring" class="com.spring.RemoveEmployeeController"&gt;
 &lt;!-- set the dependencies --&gt;
&lt;/bean&gt;


&lt;/beans&gt;
 </pre>

							<h5 id="SimpleUrlHandlerMapping">SimpleUrlHandlerMapping</h5>
							<ul>
								<li>The <strong>org.springframework.web.servlet.handler.SimpleUrlHandlerMapping</strong>
									is one of the implementation of HandlerMapping interface.</li>
								<li>This implementation defines the navigation strategy that maps the request URL's
									servlet-path to the <strong>mapping configured</strong>. i.e., It locates the
									handler(controller) by matching the request URL's servlet-path with the key of the
									given properties or Map. </li>
								<li>The SimpleUrlHandlerMapping supports the configure 2 types : <ol>
										<li>bean names</li>
										<li>bean instances</li>
									</ol>
								</li>
							</ul>

							<pre>&lt;beans&gt;
 
&lt;bean id="addEmp" class="com.spring.AddEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;

&lt;bean id="removeEmp" class="com.spring.RemoveEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;

&lt;bean id="searchEmp" class="com.spring.SearchEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;


&lt;bean id="handlerMapping" 
class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
 &lt;property name="mappings"&gt;
  &lt;props&gt;
    &lt;prop key="/addEmployee.spring"&gt;addEmp&lt;/prop&gt;
    &lt;prop key="/removeEmployee.spring"&gt;removeEmp&lt;/prop&gt;
    &lt;prop key="/searchEmployee.spring"&gt;searchEmp&lt;/prop&gt;
  &lt;/props&gt;
 &lt;/property&gt;
&lt;/bean&gt;

&lt;/beans&gt; 
</pre>

							<p>This configuration is suitable for configuring non-singleton beans</p>
							OR

							<pre>&lt;beans&gt;

&lt;bean id="addEmp" class="com.spring.AddEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;

&lt;bean id="removeEmp" class="com.spring.RemoveEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;

&lt;bean id="searchEmp" class="com.spring.SearchEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;


&lt;bean id="handlerMapping" 
class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
 &lt;property name="mappings"&gt;
  &lt;map&gt;
    &lt;entry key="/addEmployee.spring"&gt;
     &lt;ref local="addEmp"/&gt;
    &lt;/entry&gt;
    
    &lt;entry key="/removeEmployee.spring"&gt;
     &lt;ref local="removeEmp"/&gt;
    &lt;/entry&gt;
    
    &lt;entry key="/searchEmployee.spring"&gt;
     &lt;ref local="searchEmp"/&gt;
    &lt;/entry&gt;
  &lt;/map&gt;
 &lt;/property&gt;
&lt;/bean&gt;

&lt;/beans&gt;
</pre>
							<p>This configuration is suitable for configuring singleton beans</p>

							<h5 id="ControllerClassNameHandlerMapping">ControllerClassNameHandlerMapping</h5>

							<ul>
								<li>The
									<strong>org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping</strong>
									is one of the implementation of HandlerMapping interface.</li>
								<li>This handler mapping implementation is newly introduced in spring 2.0</li>
								<li>The ControllerClassNameHandlerMapping follows a simple convention for generating URL
									path mappings.</li>
								<li>The convention for simple Controller implementations is to take the short names of
									the controller class.</li>
							</ul>

							<p>Ex : If the controller class name is <b>com.emp.AddEmployeeController</b> then the path
								is <strong>addemployee*</strong></p>
							<pre>&lt;beans&gt;
 
&lt;bean id="handlerMapping" 
class="org.springframework.web.servlet.mvc.
               support.ControllerClassNameHandlerMapping"/&gt;

&lt;bean id="addEmp" class="com.spring.AddEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;

&lt;bean id="removeEmp" class="com.spring.RemoveEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;

&lt;bean id="searchEmp" class="com.spring.SearchEmployeeController"&gt;
 &lt;!-- configure dependencies --&gt;
&lt;/bean&gt;
 
&lt;/beans&gt;
</pre>




							<h5 id="CommonsPathMapHandlerMapping">CommonsPathMapHandlerMapping </h5>
							<ul>
								<li>
									The <b>org.springframework.web.servlet.handler.CommonsPathMapHandlerMapping</b> is
									one of the implementation of <b>HandlerMapping</b> interface.
								</li>
								<li>
									The <b>org.springframework.web.servlet.handler.CommonsPathMapHandlerMapping</b> is
									designed to recognize Commons attributes meta data attributes of type <b>PathMap</b>
									defined in the application controller and automatically wires them in to the current
									DiapatcherServlet's Web-application context.</li>
								<li>
									To use this HandlerMapping the controller class must have a class level metadata of
									the form
									<b>@org.springframework.web.servlet.handler.commonsattribures.PathMap("/mypath.spring").</b>
								</li>
								<li>
									We can configure multiple path maps for a single controller.</li>
							</ul>


							<pre>@org.springframework.web.servlet.handler.commonsattribures.PathMap(
                                              "/mypath.spring")
                                              
public class FirstController implements Controller {

public ModelAndView handleRequest(HttpServletRequest request,
			   HttpServletResponse response)throws Exception {
System.out.println("we are in handleRequest()");
ModelAndView mav=null;
return mav;
}  
</pre>

							<p>Note : To use commons attributes path mapping , we must compile application classes with
								Commons Attributes, and run the Commons attributes indexer tool on the application
								classes, which must be in a Jar rather than in WEB-INF/classes as an individual classes.
							</p>

							<h6 id="multiple-handler-mappings">Configuring multiple handler mappings :</h6>
							<ul>
								<li>We can configure multiple handler mappings in an application context.</li>
								<li>In such a case we need to configure an additional property 'order' that takes 'int'
									value on each of the handler mapping.</li>
							</ul>

							<pre>
</pre>



							<h3 id="preHandle-methods">Phase 3 : Execute Interceptors preHandle methods </h3>

							<ol>
								<li> After successfully locating the HandlerExcecutionChain the DispatcherServlet
									executes the HandlerInterceptors
									described by the HandlerExecutionChain returned by the HandlerMapping.</li>
								<li> The HandlerInterceprors gives us an opportunity to add common pre and
									post-processing behavior without needing to modify each handler implementation.</li>
								<li>The HandlerInterceptors is basically similar to a Servlet Filter(2.3v) . <br><br>
									<img alt="" src="mvc/springPhase3.png" height="540px" width="650px">
								</li>
								<li>The HandlerInterceptors can be used for implementing pre-processing aspects,
									for example , for authorization checks, or common handler behavior like locale or
									theme changes. </li>
							</ol>

							<h5 id="HandlerInterceptor">Using HandlerInterceptor </h5>

							Using the HandlerInterceptor includes the following 2 steps :
							<ol>
								<li>Write an HandlerInterceptor implementation</li>
								<li>Configure the interceptor</li>
							</ol>

							<h6>Write an HandlerInterceptor implementation :</h6>
							<ul>
								<li>The HandlerInterceptor can be used for implementing pre-processing aspects, for
									example, for authorization checks, or common handler behavior like locale or theme
									changes.</li>
								<li>The Spring framework includes built-in HandlerInterceptor's implementing the most
									common pre-processing concerns like locale and theme change.</li>
							</ul>

							The following are the built-in HandlerInterceptor implementations
							<ul>
								<li>org.springframework.web.servlet.i18n.LocaleChangeInterceptor</li>
								<li>org.springframework.web.servlet.theme.ThemeChangeInterceptor</li>
							</ul>

							Apart from the built-in HandlerInterceptors we can write HandlerInterceptor implementations
							encapsulating the custom pre- and post-processing logics.



							<pre>package com.spring;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

public class MyHandlerInterceptor implements HandlerInterceptor {
	
public boolean preHandle(HttpServletRequest request,
		    HttpServletResponse response,
			Object handler) throws Exception {
	
System.out.println("preHandle() executes at phase 3");

/*
Do some preprocessing like check the security etc

return boolean value accordingly,
if we want to continue the interceptor chain  returns true
*/

return false;
}

public void postHandle(HttpServletRequest request,
	    HttpServletResponse response,
		Object handler, ModelAndView mav) throws Exception {

System.out.println("afterCompletion() executes at phase 5");
      //Do some postprocessing
}

public void afterCompletion(HttpServletRequest request, 
		HttpServletResponse response, 
		Object handler, Exception ex)throws Exception {

System.out.println("afterCompletion() executes at phase 5");
        //Do finalizations
}

}
</pre>








							<h6>Configuring the interpretor :</h6>





							<pre>&lt;beans&gt;
&lt;bean id="myInterceptor" class="com.spring.MyHandlerInterceptor"/&gt;

&lt;bean id="handlerMapping" 
class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;
 &lt;property name="interceptors"&gt;
  &lt;list&gt;
   &lt;ref local="myInterceptor"/&gt;
  &lt;/list&gt;
 &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</pre>





							<h3 id="Invoke-Handler">Phase 4 : Invoke Handler </h3>
							<ol>
								<li>In this phase of Spring web MVC request processing workflow the DispatcherServlet
									delegates the request to the handler that is located by the HandlerMapping in Phase
									2.</li>
								<li>DispatcherServlet uses HandlerAdapter to delegate the request to the handler located
									to handle this request.</li>
							</ol>

							<ul>
								<li>
									<strong>step 1 : Prepare a iterator of HandleAdapter collection :</strong>
									<ol type="i">
										<li>In this Phase workflow starts with preparing an iterator of the collection
											representing the HandlerAdapter objects configured in the application.</li>
										<li>The handlerAdapters collection is initialized in the initialization phase of
											the DispatcherServlet where it finds all HandlerAdapters in the
											ApplicationContext.</li>
										<li>If no HandlerAdapter beans are defined in the application then the default
											is considered as SimpleControllerHandlerAdapter. Thus the handlerAdapters
											collection contains at least one element.</li>
									</ol>
								</li>

								<li><strong>step 2 : Get HandlerAdapter : </strong>
									<ol type="i">
										<li>In this step the workflow obtains the next element from the iterator in step
											1 and casts it into HandlerAdapter type reference.</li>

									</ol>
								</li>

								<li><strong>step 3 : Find is HandlerAdapter compatible : </strong>
									<ol type="i">
										<li>After getting the HandlerAdapter of the current iteration the workflow
											continues with finding whether this HandlerAdapter is suitable for the
											handler located in phase 2.</li>
										<li>This is done by invoking supports() method on the HandlerAdapter.</li>
										<li>If it returns "true" then it indicates that this HandlerAdapter supports the
											handler. In such a case the workflow continues to the next step.</li>
										<li>If the supports() returns "false" then the work flow continues finding
											whether there is a next element in the handlerAdapter Collection , if found
											then it moves to step 2. If not then ServletException is thrown, delegating
											the workflow to phase 6.</li>
									</ol>
								</li>

								<li><strong>step 4 : Execute handler :</strong>
									<ol type="i">
										<li>After successfully locating the HandlerAdapter that supports the handler
											that is located in phase 2, the workflow proceeds to invoke handle() method
											of HandlerAdapter which further delegates the request to the handler(may be
											controller). </li>
										<li>If the handle() method throws any exception then the workflow proceeds to
											phase 6 , if not it proceeds to phase 5 after collecting the ModelAndView
											object reference returned by the handle() method.</li>
									</ol>
								</li>
							</ul>

							<img alt="" src="mvc/springPhase4.png" height="540px" width="650px">

							<h6 id="HandlerAdapter">The HandlerAdapter :</h6>
							<ol>
								<li>The HandlerAdapter implementation takes the responsibility of identifying the type
									of handler and invokes its appropriate methods.</li>
								<li>The use of HandlerAdapter facilitates us to use Plain Old Java Objects (POJOs) with
									any method encapsulating the handler behavior , as a handler. </li>
								<li>Spring provides the built-in HandlerAdapter implementations supporting different
									types of handlers to work with.</li>
								<li>The various types of handlers supported by the Spring built-in HandlerAdapter are
									controller types, HttpRequestHandler types, Servlet types, and ThrowawayController
									types.</li>
								<li>The org.springframework.web.servlet.HandlerAdapter interface declares three methods
									(supports(), handle(), getLastModified()) that have to be implemented by the
									HandlerAdapter implementations to help DiapatcherServlet in delegating the request
									to the handlers.</li>
							</ol>
							Spring built-in HandlerAdapter implementations :
							<ol>
								<li>SimpleControllerHandlerAdapter</li>
								<li>ThrowawayControllerHandlerAdapter</li>
								<li>HttpRequestHandlerAdapter</li>
								<li>SimpleServletHandlerAdapter</li>
							</ol>
							Note :
							<ul>
								<li> By default only the SimpleControllerHandlerAdapter and
									ThrowawayControllerHandlerAdapter handler adapters are available to the
									DispatcherServlet.</li>
								<li> Other handler adapters need to be explicitly configured, as normal as other beans
									in the context Spring Beans XML configuration file of DispatcherServlet. </li>
								<li>Even though Spring supports implementing the custom handler adapters that enables
									handling the request using user defined type of handlers (without making them depend
									on the Spring API), however it is recommended to use the Spring Controller
									infrastructure to implement the handler.</li>
								<li> The custom handler adapter option is given to support some situation where we want
									to use the existing handlers without rewriting them as spring defined controllers.
								</li>
							</ul>

							<p>The HandlerAdapter uses handler to handle the request and results returning the
								ModelAndView object.</p>



							<pre> package com.spring;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.ModelAndView;

public class MyHandlerAdapter implements HandlerAdapter {

public boolean supports(Object handler) {
return (handler instanceof com.spring.MyHandler);
}

public ModelAndView handle(HttpServletRequest request,
		HttpServletResponse response, Object handler) throws Exception {

MyHandler myHandler=(MyHandler) handler;
String view=myHandler.process(request,response);
Map model=(Map)request.getAttribute("model");

if(view==null)
	return null;
else if(model==null)
	return new ModelAndView(view);
else
	return new ModelAndView(view,model);

}

public long getLastModified(HttpServletRequest request, Object handler) {

return -1;
}

}
</pre>


							<pre>package com.spring;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public interface MyHandler {

String process(HttpServletRequest request,
	HttpServletResponse response) throws Exception;
} 
</pre>



							<h5 id="ModelAndView">ModelAndView :</h5>
							<ul>
								<li>The ModelAndView is a value object designed to hold model and view making it
									possible for a handler to return both model and view in a single value.</li>
								<li>The ModelAndView object represents a model and view specified by the handler, which
									is resolved by the DispatcherServlet using the special framework objects as
									ViewResolver and View.</li>
								<li>The view is an object that can describe a view name in the form of String which will
									be resolved by a ViewResolver object to locate View object, alternatively, a View
									object directly.</li>
								<li>The Model is a Map, enabling to specify multiple objects.</li>
							</ul>




							<h3 id="postHandle-methods">Phase 5 : Execute Interceptors postHandle methods </h3>
							<ul>
								<li> HandlerInterceptor gives us an opportunity to add common pre- and post-processing
									behavior without needing to modify each handler implementation.</li>
								<li> The post-processing operations like changing the logical view name in the
									ModelAndView based on some inputs/output to support different types of views.</li>
							</ul>


							<dl>
								<dt><strong>Step 1 : Prepare the Counter :</strong></dt>
							</dl>
							<ul>
								<li>In this phase workflow starting with setting the count to one minus the
									interceptor's length so that the postHandle method can be invoked on the
									interceptor's in the reverse order.</li>
								<li>If the interceptors length is 0(zero) then the workflow proceeds to Phase 7 or 8
									based on whether the the handler in Phase 4 has returned a valid ModelAndView object
									reference or null.</li>
								<li> If there are any interceptors configured then the workflow proceeds to the next
									step of this phase. </li>
							</ul>

							<dl>
								<dt><strong>Step 2 : Invoke postHandle() method :</strong></dt>
							</dl>
							<ul>
								<li>Here it obtains the HandlerInterceptor at the current count and uses it to invoke
									postHandle() method.</li>
								<li>If the postHandle() method throws any exception then the worlflow proceeds to Phase
									6 to handle the exception.</li>
								<li>If the postHandle() method execution is successful (i.e., normal termination) then
									count is decremented by 1, if the count is grater than or equal to 0(zero) then
									repeat step2 (i.e., this step) once again.</li>
								<li>If the count is less than 0(zero) then the workflow proceeds to Phase 7 or Phase 8
									based on the result of Phase 4.</li>
								<li>That is, if the handler in Phase 4 has returned a valid ModelAndView object
									reference then workflow proceeds to Phase 7 to render the view, If the handler had
									returned null then the workflow proceeds to Phase 8 considering that the handler had
									prepared the response.</li>
							</ul>

							<img alt="" src="mvc/springPhase5.png" height="540px" width="650px">

							<h3 id="Handle-Exceptions">Phase 6 : Handle Exceptions </h3>

							<img alt="" src="mvc/springPhase6.png" height="540px" width="650px"> <br>

							<ul>
								<li> This Phase of the Spring Web MVC request processing flow is executed only when
									there is any exception raised while executing interceptors preHandle() or
									postHandle() methods or the handler.</li>
								<li>DispatcherServlet uses HandlerExceptionResolver to handle the exceptions thrown by
									the HandlerInterceptor or handler.</li>
							</ul>

							<p>Note : Spring does not take a default type for HandlerExceptionResolver</p>





							<dl>
								<dt><strong>Step 1 : Prepare an iterator of exception resolvers :</strong></dt>
							</dl>
							<ul>
								<li>Preparing an iterator of the Collection representing HandlerExceptionResolver
									objects configured in the application.</li>
								<li>The handlerExceptionResolvers Colletion is initialized in the initialization phase
									of the DispatcherServlet where it finds all HandlerExceptionResolver's in the
									ApplicationContext.</li>
								<li> If no HandlerExceptionResolver beans are defined in the application then this
									collection will be empty.</li>
								<li>If the handlerExceptionResolvers collection is empty then it considers that there
									are no exception handlers for the application, thus the workflow proceeds to Phase 8
									which then ends the request processing by throwing the same exception.</li>
								<li>If the collection is not empty then the workflow continues to the next step of this
									phase.</li>
							</ul>



							<dl>
								<dt><strong>Step 2 : Get HandlerExceptionResolver :</strong></dt>
							</dl>

							In this step the work flow obtains the next element from the iterator prepared in step 1,
							and casts into HandlerExceptionResolver type reference.



							<dl>
								<dt><strong>Step 3 : Invoke resolveException() method :</strong></dt>
							</dl>
							<ul>
								<li>After getting the HandlerExceptionResolver of the current iteration the
									resolveException() method is invoked to handle the exception.</li>
								<li>If the resolveException() method returns a valid ModelAndView object reference then
									the workflow proceeds to phase 7 for rendering a response.</li>
								<li>If the resolveException() method returns null then it finds whether the next element
									is available in the iterator.</li>
								<li>If so, then the work flow proceeds to step2 of this phase. If the next element is
									not available, then the workflow proceeds to phase 8 which then ends the request
									processing by throwing the same exception.</li>
							</ul>



							<pre>&lt;beans&gt;
&lt;bean id="handlerExceptionResolver"
 class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt;
 &lt;property name="exceptionMappings"&gt;
  &lt;props&gt;
   &lt;prop key="org.springframework.dao.EmptyResultDataAccessException"&gt;
    /sqlError.html
   &lt;/prop&gt;
   
   &lt;prop key="org.springframework.web.HttpRequestMethodNotSupportedException"&gt;
    /myError.html
   &lt;/prop&gt;
  &lt;/props&gt;
 &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</pre>



							<br><br>

							login.html
							<pre>&lt;body&gt;
 &lt;form action="/login.spring" &gt; &lt;br&gt; // / is optional
 User Name : &lt;input type="text" name="userName"&gt; &lt;br&gt;
 Password: &lt;input type="password" name="password"&gt; &lt;br&gt;
 &lt;input type="submit" value="Login"&gt;
 &lt;/form&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>

							LoginController.java
							<pre>package com.spring;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;


public class LoginController implements Controller {

LoginModel loginModel;
public void setLoginModel(LoginModel lm){
 loginModel=lm;
}
	
public ModelAndView handleRequest(HttpServletRequest request,
			HttpServletResponse response) throws Exception {
String userName=request.getParameter("userName");
String password=request.getParameter("password");
System.out.println("userName : "+userName);
System.out.println("password : "+password);
String type = loginModel.getValidate(userName,password);

System.out.println("type : "+type);

if(type==null)
	//return new ModelAndView("/login.html");
	throw new MyException("User details are not valid");
else if(type.equals("admin"))
	return new ModelAndView("/pages/admin.jsp");
else
	return new ModelAndView("/pages/user.jsp");

} //handleRequest
}
</pre>

							LoginModel.java
							<pre>package com.spring;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;

public class LoginModel {

private JdbcTemplate jdbcTemplate;

public LoginModel(JdbcTemplate jdbcTemplate) {
this.jdbcTemplate=jdbcTemplate;
}

public String getValidate(String userName, String password) {
	
 String sql="select type from UserDetails where username=\'"
	         + userName+ "\' and password=\'"+password+ "\' ";
 
 try{
	return jdbcTemplate.queryForObject(sql, String.class);	
 }catch (EmptyResultDataAccessException e) {
	 return null;
} 

} //getValidate()

}
</pre>
							admin.jsp
							<pre>Wel come to Admin page &lt;br/&gt;

User Name : &lt;%= request.getParameter("userName") %&gt;
</pre>

							user.jsp
							<pre>Wel come to User page &lt;br/&gt;

User Name : &lt;%= request.getParameter("userName") %&gt;
</pre>

							myError.html
							<pre>&lt;body&gt;
A simple test error page &lt;br&gt;
User details are not valid   
&lt;/body&gt;
</pre>

							ds-servlet.xml
							<pre>&lt;beans&gt;

&lt;!-- configure DataSource --&gt;
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;
&lt;property name="driverClassName"&gt;
 &lt;value&gt;oracle.jdbc.driver.OracleDriver&lt;/value&gt;
&lt;/property&gt;
&lt;property name="url"&gt;
 &lt;value&gt;jdbc:oracle:thin:@localhost:1521:xe&lt;/value&gt;
&lt;/property&gt;
&lt;property name="username"&gt;
 &lt;value&gt;lms&lt;/value&gt;
&lt;/property&gt;
&lt;property name="password"&gt;
 &lt;value&gt;scott&lt;/value&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- configure JdbcTemplate --&gt;
&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
 &lt;constructor-arg&gt;
  &lt;ref local="dataSource" /&gt;
 &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="loginModel" class="com.spring.LoginModel"&gt;
 &lt;constructor-arg&gt;
  &lt;ref local="jdbcTemplate"/&gt;
 &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="loginController" class="com.spring.LoginController"&gt;
 &lt;property name="loginModel"&gt;
  &lt;ref local="loginModel"/&gt;
 &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="handlerMapping" 
  class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
&lt;property name="mappings"&gt;
 &lt;props&gt;
  &lt;prop key="/login.spring"&gt;loginController&lt;/prop&gt;
 &lt;/props&gt;
&lt;/property&gt;
&lt;/bean&gt;


&lt;bean id="handlerExceptionResolver"
  class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt;
 &lt;property name="exceptionMappings"&gt;
  &lt;props&gt;
   &lt;prop key="com.spring.MyException"&gt;
    /myError.html
   &lt;/prop&gt;
  &lt;/props&gt;
 &lt;/property&gt;
&lt;/bean&gt;

&lt;/beans&gt;
</pre>

							web.xml
							<pre>&lt;web-app&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;ds&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;load-on-startup&gt;0&lt;/load-on-startup&gt;

&lt;/servlet&gt;	
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;ds&lt;/servlet-name&gt;
&lt;url-pattern&gt;*.spring&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
  
&lt;/web-app&gt;
</pre>

							<h3 id="Render-the-View">Phase 7 : Render the View </h3>

							The Spring Web Mvc request processing workflow executes this phase only in the following two
							cases :
							<ol>
								<li>If the handler in Phase 4 retuns a valid(not null) ModelAndView object reference,
									and phase 5 is executed successfully (i.e., postHandle() method of
									HandlerInterceptors).</li>
								<li>If the HandlerExceptionResolver in phase 6 returns a valid (not null) ModelAndView
									object reference.</li>
							</ol>



							<img alt="" src="mvc/springPhase7.png" height="540px" width="650px">

							<h6>Step 1 : Find the View :</h6>
							<ul>
								<li>The work flow of Phase 7 of Spring Web Mvc request processing work flow starts with
									finding for the view in the ModelAndView object produced in the previous phases
									(Phase 4 or 6).</li>
								<li>This is done using the hasView() method of ModelAndView. If hasView() method returns
									false i.e., the ModelAndView object does not contain a view , then a default view
									name is set to the ModelAndView object.</li>
								<li>The default view name is obtained by DispatcherServlet using the
									RequestToViewNameTranslator type object configured in this context.</li>
								<li>If there is no RequestToViewNameTranslator type bean configured in the context then
									null is set as view name.</li>
							</ul>

							<h6>Step 2 : Find the ModelAndView contains View reference :</h6>
							<ul>
								<li>After the successful execution of step 1 the work flow continues with finding
									whether the view in the ModelAndView object is holding a View object reference or a
									view name. This is done using the isReference() method of ModelAndView.</li>
								<li>If isReference() method returns 'false' and if the view reference is not null then
									the work flow proceeds to the next step.</li>
								<li>If isReference() method returns 'true' then the work flow proceeds to resolve the
									view name. The 'Resolve View Name' process is explained in the next section. If the
									'Resolve View Name' process successfully resolves the view name to View object then
									the workflow proceeds to the next step.</li>
								<li>If the view reference is null or the ViewResolver's fails to resolve the view
									name(i.e., if 'Resolve View Name' process returns null), the workflow proceeds to
									phase 8 by throwing a ServletException.</li>
							</ul>


							<h6>Step 3 : Delegate to View object for rendering :</h6>

							<ul>
								<li>After successfully locating the View object the request is delegated to the view
									object invoking render() method of View.</li>
								<li>The view object takes the responsibility to prepare the response, i.e., presentation
									for the client.</li>
								<li>Thereafter, the workflow proceeds to Phase 8 to perform the finalizations.</li>
							</ul>


							<h5 id="Resolve-View-Name">The 'Resolve View Name' process :</h5>
							<ul>
								<li> As described in the preceding section if the ModelAndView object describes a view
									name instead of View object, Dispatcherservlet uses the configured ViewResolver
									object to resolve the view name to locate View object.</li>
								<li>As an overview at this point we can simply consider that the ViewResolver object is
									responsible to locate the View object that can render a view for this request.</li>
							</ul>

							<strong>Step 1 : Prepare a ViewResolver Iterator </strong>
							<ul>
								<li> The wokflow starts with the preparation of an iterator of the collection storing
									the ViewResolver objects. This collection is created while the DispatcherServlet is
									being initialized. Thereafter the first element is retrieved from the iterator.</li>
							</ul>

							<strong>Step 2 : Resolve View Name</strong>
							<ul>
								<li>
									After step 1 the workflow proceeds to invoke the resolveViewName() method of the
									current ViewResolver object in the iteration.</li>
								<li>If the resolveViewName() method returns null, which indicates that the current
									ViewResolver failed to resolve the view name.</li>
								<li>In this case the workflow proceeds to the next step. If the resolveViewName() method
									returns a valid View object reference then the workflow completes returning the
									same, which is further used to render the view as described in the preceding
									section.</li>
							</ul>

							<img alt="" src="mvc/springPhase71.png" height="540px" width="650px">

							<br>

							<strong>Step 3 : Move to next element </strong>
							<ul>
								<li>If the ViewResolver in the preceding step fails to resolve the view name then the
									workflow proceeds to get the next ViewResolver from the iterator prepared in step 1.
								</li>
								<li>If the next element is available then the process moves to step 2, if not the
									workflow completes returning null.</li>
							</ul>


							<h3 id="afterCompletion-methods">Phase 8 : Execute Interceptors afterCompletion methods
							</h3>
							<ul>
								<li>As explained in Phase 3, the HandlerInterceptor gives us an opportunity to add
									common pre- and post-processing behavior without needing to modify each handler
									implementation.</li>
								<li>While in Phase 3, the preHandle() method of handler interceptors are executed,<br>
									And in Phase 5, the postHandle() methods are executed.</li>
								<li>In this phase of workflow the afterCompletion() method is executed on the Handler
									Interceptors whose preHandle() method has successfully executed and returned
									'true'(i.e., in Phase 3).</li>
								<li>The afterCompletion() method is called on any outcome of handler execution, thus
									allowing us to do the resource cleanup.</li>
							</ul>
							<img alt="" src="mvc/springPhase8.png" height="540px" width="650px">

							<h6> Step 1 : Prepare counter : </h6>
							<ul>
								<li>The workflow of Phase 8 starts with setting the count to interceptorIndex value.
								</li>
								<li>The interceptorIndex is set in the preprocessing phase, i.e., Phase 3 used to track
									the index of the interceptor in the list that have completed the preHandle
									processing successfully so that in this phase the afterCompletion methods can be
									executed only on those HandlerInterceptors.</li>
								<li>That is, if the workflow reaches to this phase from Phase 5 then the
									interceptorIndex will be equal to the interceptors length minus 1(interceptorsLength
									- 1) since the preHandle() of all the interceptors are executed successfully. </li>
								<li>Thus the afterCompletion() will be executed on all interceptors in reverse order as
									compared to the order in which they are configured.</li>
								<li>If the workflow reaches to this phase because of any exception raised in the
									preHandle() or if preHqndle() returns 'false' then the interceptor chain stops
									execution the preHandle methods and delegates to this phase via Phase 6 or directly.
								</li>
								<li>After the counter is prepared if there are any interceptors configured, i.e., if the
									count is greater than or equal to 0(zero) then the workflow proceeds to step 2, if
									not it ends the request processing doing the necessary cleanup operations.</li>
							</ul>


							<h6>Step 2 : Obtain HandlerInterceptor : </h6>
							After the counter is prepared successfully DispatcherServlet obtains the HandlerInterceptor
							at the current index from the interceptors list.


							<h6>Step 3 : Invoke interceptors afterCompletion() method : </h6>
							After obtaining the HandlerInterceptor DispatcherServlet invokes afterCompletion() method.

							<h6>Step 4 : Change the counter : </h6>
							<ul>
								<li>In the step of Phase 8 workflow the count is decrease by one and then verifies
									whether the current count is greater than or equal to 0(zero).</li>
								<li>If so then the workflow proceeds to step 2 of this phase, if not it ends the request
									processing doing the necessary cleanup operations.</li>
							</ul>
							<p>With in this phase the Spring Web MVC request processing workflow ends.</p>

						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<style>
		.footerfont {
			font-size: 16px
		}
	</style>
	<div class="footer footerfont" style="background: #55585a;">
		<div class="footer-copyright border-top ">
			<div class="container">
				<div class="row">
					<div class="col-sm-6 center py-3 text-white">
						Copyright  2023, <br>The content is copyrighted to Ravi Kalyan Kolloju.
					</div>
				</div>
			</div>
		</div>
	</div>
</body>

</html>