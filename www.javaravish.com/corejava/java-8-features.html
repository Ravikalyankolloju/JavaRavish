<!DOCTYPE html>
<html lang="en">
<meta http-equiv="content-type" content="text/html;charset=UTF-8" />

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="author" content="Java By Ravi Kalyan">

	<title>Java Ravish | Java 8 Features</title>

	<link rel="shortcut icon" type="image/x-icon" href="../scripts/images/favicon/android-chrome-192x192.png" />
	<link rel="apple-touch-icon" href="../scripts/images/favicon/apple-touch-icon.jpeg">
	<link href="../scripts/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="../scripts/css/customcss.css">

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js"></script>
	<style>
		.div-to-hide {
			display: block;
			/* Display the div by default */
		}

		@media screen and (max-width: 767px) {
			.div-to-hide {
				display: none;
				/* Hide the div on screens smaller than 768px (mobile) */
			}
		}
	</style>
</head>

<body>
	<nav class="navbar navbar-expand-lg border-bottom navbarmenu fixed-top bg-white">
		<div class="container p-0">
			<a class="navbar-brand pull-left" href="../main/home.html"><img src="../scripts/images/jrlogo.PNG"
					style="height: 50px; max-width: 100%;" alt="java by Kalyan" title="Java Ravish Tutorials"></a>
			<button class="w3-button w3-teal w3-hide-large" type="button" data-toggle="collapse"
				data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
				&#9776;
			</button>
			<div class="collapse navbar-collapse pull-right" id="navbarResponsive">
				<ul class="navbar-nav ml-auto text-center">
					<li class="nav-item"><a class="nav-link" href="../main/home.html"><img
								src="../scripts/images/small/home.jpg"></i></a>
					</li>
					<li class="nav-item"><a class="nav-link" href="../corejava/java-introduction.html">Java</a></li>
					<li class="nav-item"><a class="nav-link" href="../spring/spring-introduction.html">Spring</a></li>
					<li class="nav-item"><a class="nav-link" href="../springboot/sb-introduction.html">SpringBoot</a>
					</li>
					<li class="nav-item"><a class="nav-link" href="../main/interview-questions.html">Interview
							Questions</a></li>

				</ul>
			</div>
		</div>
	</nav>
	<br>
	<div class="container-fluid">
		<br />
		<ol class="breadcrumb no-padding  mt-5 bg-light nohighlight">
			<li itemprop="itemListElement" class="breadcrumb-item">
				<a class="text-dark" itemprop="item" href="../main/home.html"> <span itemprop="name">Home</span>
				</a>
				<meta itemprop="position" content="1" />
			</li>
			<li itemprop="itemListElement" class="breadcrumb-item">
				<a class="text-dark" itemprop="item" href="java-introduction.html"> <span itemprop="name">Java</span>
				</a>
				<meta itemprop="position" content="2" />
			</li>
			<li itemprop="itemListElement" class="breadcrumb-item">
				<a class="text-dark" itemprop="item" href="#">
					<span itemprop="name">Java 8 Features</span>
				</a>
			</li>
		</ol>
		<div class="row">
			<link rel="stylesheet" href="../scripts/css/sidebarcollapsecss.css">
			<button class="w3-button w3-teal w3-hide-large" type="button" data-toggle="collapse"
				data-target="#sideBarResponsive" aria-controls="sideBarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
				&#9776;
			</button>
			<div class="col-lg-3 w3-collapse w3-animate-right hidesidebar sidebarfont" id="mySidebar" role="tablist"
				aria-multiselectable="true">
				<div class="collapse card" id="sideBarResponsive">
					<h2 class="card-header text-white" style="background: rgb(0,0,0);">Java</h2>
					<div class="list-group">
						<ul class="leftBarList">
							<li><a href="java-introduction.html">Java Introduction</a></li>
							<li><a href="java-languag-fundamentals.html">Java Language Fundamentals</a></li>
							<li><a href="java-access-modifiers.html">Access Modifiers</a></li>
							<li><a href="java-flow-control.html">Flow Control</a></li>
							<li><a href="java-oops.html">Object Oriented Programming</a></li>
							<li><a href="java-vm-memory-management.html">JVM Memory Management</a></li>
							<li><a href="java-garbage-collection.html">Garbage Collection</a></li>
							<li><a href="java-inner-classes.html">Inner Classes</a></li>
							<li><a href="java-abstraction.html">Abstraction</a></li>
							<li><a href="java-encapsulation.html">Encapsulation</a></li>
							<li><a href="java-polymorphism.html">Polymorphism</a></li>
							<li><a href="java-inheritance.html">Inheritance </a></li>
							<li><a href="java-exception.html">Exception Handling</a></li>
							<li><a href="java-multithreading.html">Multithreading</a></li>
							<li><a href="java-lang-package.html">Fundamentals of java.lang.package</a></li>
							<li><a href="java-serialization.html">Serialization</a></li>
							<li><a href="java-generics.html">Generics</a></li>
							<li><a href="java-collection-framework.html">Collection Framework</a></li>
							<li><a href="java-internationalization.html">Internationalization</a></li>
							<li><a href="java-8-features.html">Java 8 Features</a></li>
							<li><a href="java-interview-questions.html">Java Interview Questions</a></li>
						</ul>
					</div>
				</div>
				<div class="div-to-hide card" id="sideBarResponsive">
					<h2 class="card-header text-white" style="background: rgb(0,0,0);">Java</h2>
					<div class="list-group">
						<ul class="leftBarList">
							<li><a href="java-introduction.html">Java Introduction</a></li>
							<li><a href="java-languag-fundamentals.html">Java Language Fundamentals</a></li>
							<li><a href="java-access-modifiers.html">Access Modifiers</a></li>
							<li><a href="java-flow-control.html">Flow Control</a></li>
							<li><a href="java-oops.html">Object Oriented Programming</a></li>
							<li><a href="java-vm-memory-management.html">JVM Memory Management</a></li>
							<li><a href="java-garbage-collection.html">Garbage Collection</a></li>
							<li><a href="java-inner-classes.html">Inner Classes</a></li>
							<li><a href="java-abstraction.html">Abstraction</a></li>
							<li><a href="java-encapsulation.html">Encapsulation</a></li>
							<li><a href="java-polymorphism.html">Polymorphism</a></li>
							<li><a href="java-inheritance.html">Inheritance </a></li>
							<li><a href="java-exception.html">Exception Handling</a></li>
							<li><a href="java-multithreading.html">Multithreading</a></li>
							<li><a href="java-lang-package.html">Fundamentals of java.lang.package</a></li>
							<li><a href="java-serialization.html">Serialization</a></li>
							<li><a href="java-generics.html">Generics</a></li>
							<li><a href="java-collection-framework.html">Collection Framework</a></li>
							<li><a href="java-internationalization.html">Internationalization</a></li>
							<li><a href="java-8-features.html">Java 8 Features</a></li>
							<li><a href="java-interview-questions.html">Java Interview Questions</a></li>
						</ul>
					</div>
				</div>
				<br>
			</div>



			<div class="col-lg-9 mb-4">
				<div class="card h-100">
					<h1 class="card-header text-white" style="background: rgb(0,0,0);">Java 8 Features</h1>
					<div class="card-body">
						<div class="tab" role="tabpanel">
							<ol>
								<li><a href="#lambda"> Lambda Expressions </a></li>
								<li><a href="#functional"> Functional Interfaces</a>
								</li>
								<li><a href="#file">Functional
										Interface Vs Lambda Expressions</a></li>
								<li><a href="#anonymous">Anonymous inner classes vs Lambda Expressions</a></li>
								<li><a href="#default"> Default methods in
										Interfaces</a></li>
								<li><a href="#static"> Static Methods in
										Interfaces</a></li>
								<li><a href="#predicate"> Predicate</a></li>
								<li><a href="#functions"> Functions</a></li>
								<li><a href="#consumer"> Consumer</a></li>
								<li><a href="#supplier"> Supplier</a></li>
								<li><a href="#double-colon"> Method Reference &amp;
										Constructor Reference by Double Colon(::) Operator</a></li>
								<li><a href="#stream-api"> Pipelines and Stream API</a></li>
								<li><a href="#joda-time"> Date &amp; Time API ( Joda
										API)</a></li>
								<li><a href="#stream"> Type Annotations</a></li>
								<li><a href="#stream"> Nashorn JavaScript Engine</a></li>
								<li><a href="#stream"> Concurrent Accumulators</a></li>
								<li><a href="#stream"> Parallel operations</a></li>
								<li><a href="#stream"> PermGen Space Removed</a></li>
								<li><a href="#stream"> TLS SNI</a></li>
							</ol>
							<pre>java 7 - July 28th 2011
Java 8 - March 18th 2014
Java 9 - September 22nd 2016
Java 10 - 2018
After Java 1.5version, Java 8 is the next major version.
 </pre>
							<p>
								Before Java 8, sun people gave importance only for objects but in 1.8version oracle
								people gave the importance for functional aspects of programming to bring its
								benefits to Java.
								i.e, it doesn't mean Java is functional oriented programming language.</p>
							<hr>
							<h2 id="lambda"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="lambda">1. Lambda Expression : </h2>

							History:
							<ul>
								<li>Lambda calculus is a big change in mathematical world which has been introduced in
									1930. Because of benefits of Lambda calculus slowly this concepts started using in
									programming world.</li>
								<li>LISP is the first programming which uses Lambda Expression.</li>
								<li>The other languages which uses lambda expressions are: C#, .Net, C Objective, C,
									C++, Python, Ruby etc. and finally in Java also.</li>
							</ul>


							<p>The Main Objective of Lambda Expression is to bring benefits of functional programming
								into Java.</p>


							What is Lambda Expression:
							<ul>
								<li>Lambda Expression is just an anonymous (nameless) function. That means the function
									which doesn't have the name, return type and access modifiers.</li>
								<li>Lambda Expression also known as anonymous functions or closures.</li>
							</ul>
							<pre>Ex: 1
public void m1() {
sop("hello"");
}

lambda ex:

() -&gt;{
	sop("hello"");
	}
() -&gt; { sop("hello"); }
() -&gt; sop("hello");



Ex:2
public void add(int a, int b) {
sop(a+b);
}

lambda ex:
(int a, int b) -&gt; sop(a+b);
</pre>

							<ul>
								<li> If the type of the parameter can be decided by compiler automatically based on the
									context then we can remove types also.</li>
								<li> The above Lambda expression we can rewrite as
									<pre>(a,b) -&gt; sop (a+b);</pre>
								</li>
							</ul>


							<pre>Ex: 3
public String str(String str) {
return str;
}

Lambda ex:
(String str) -&gt; return str;
(str) -&gt; str;
</pre>

							<h2 class="breadcrumb"> Conclusions:</h2>
							<ol>
								<li>A lambda expression can have zero or more number of parameters (arguments).
									<pre>Ex:
() -&gt; sop("hello");
(int a ) -&gt; sop(a);
(int a, int b) -&gt; return a+b;
</pre>
								</li>
								<li>Usually we can specify type of parameter. If the compiler expects the type based
									on
									the context then we can remove type. i.e., programmer is not required.
									<pre>Ex:
(int a, int b) -&gt; sop(a+b);
(a,b) -&gt; sop(a+b);
</pre>
								</li>
								<li>If multiple parameters present then these parameters should be separated with
									comma
									(,).
								</li>
								<li>If zero number of parameters available then we have to use empty parameter [
									like
									()].
									<pre>Ex: () -&gt; sop("hello");
</pre>
								</li>
								<li>If only one parameter is available and if the compiler can expect the type then
									we
									can remove the type and parenthesis also.
									<pre>Ex:
(int a) -&gt; sop(a);
(a)-&gt; sop(a);
a -&gt; sop(a);
</pre>
								</li>
								<li>Similar to method body lambda expression body also can contain multiple
									statements.
									If more than one statements present then we have to enclose inside within curly
									braces. If one statement present then curly braces are optional.
								</li>
								<li>Once we write lambda expression we can call that expression just like a method,
									for
									this functional interfaces are required.
								</li>
							</ol>
							<h2 id="functional"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="functional"> 2. Functional Interfaces</h2>

							If an interface contain only one abstract method, such type of interfaces are called
							functional interfaces and the method is called functional method or single abstract
							method
							(SAM).
							<pre>Ex:
1) Runnable -&gt; It contains only run() method
2) Comparable -&gt; It contains only compareTo() method
3) ActionListener -&gt; It contains only actionPerformed()
4) Callable -&gt; It contains only call() method
</pre>

							Inside functional interface in addition to single Abstract method (SAM) we write any
							number
							of default and static methods.
							<pre>Ex: 
1) interface Interface { 
2) public abstract void m1(); 
3) default void m2() { 
4) System.out.println ("hello"); 
5) } 
6) }
</pre>

							In Java 8, Sun MicroSystem introduced @FunctionalInterface annotation to specify that
							the
							interface is Functional Interface.
							<pre>Ex:
@FunctionalInterface
interface Interf { //This code compiles without any compilation errors.
public void m1();
}
</pre>
							Inside Functional Interface we can take only one abstract method,
							if we take more than one abstract method then compiler raise an error message that is
							called
							we will get compilation error.

							<pre>Ex:
@FunctionalInterface 
interface Interf { 
public void m1(); //This code gives compilation error.
public void m2();
}
</pre>

							Inside Functional Interface we have to take exactly only one abstract method.
							If we are not declaring that abstract method then compiler gives an error message.
							<pre>Ex:
@FunctionalInterface
interface Interface { //compilation error
}
</pre>

							<h3>Functional Interface with respect to Inheritance:</h3>


							If an interface extends Functional Interface and child interface doesn't contain any
							abstract method then child interface is also Functional Interface

							<pre>Ex: 
1) @FunctionalInterface 
2) interface A { 
3) public void methodOne(); 
4) } 

5) @FunctionalInterface 
6) interface B extends A {  //No Compile Time Error
7) }
</pre>

							In the child interface we can define exactly same parent interface abstract method.
							<pre>Ex: 
1) @FunctionalInterface 
2) interface A { 
3) public void methodOne(); 
4) } 

5) @FunctionalInterface 
6) interface B extends A { 
7) public void methodOne();  //No Compile Time Error
8) }
</pre>

							In the child interface we can't define any new abstract methods otherwise child
							interface
							won't be Functional Interface and if we are trying to use @FunctionalInterface
							annotation
							then compiler gives an error message.


							<pre>1) @FunctionalInterface { 
2) interface A { 
3) public void methodOne();
4) } 
5) @FunctionalInterface 
6) interface B extends A { 
7) public void methodTwo();  //Compile Time Error
8) }
</pre>

							<pre>Ex:
@FunctionalInterface
interface A {
public void methodOne(); //No Compile Time Error
}
interface B extends A {
public void methodTwo(); //This's Normal interface so that code compiles without error
}
</pre>

							<p>In the above example in both parent &amp; child interface we can write any number of
								default
								methods and there are no restrictions. Restrictions are applicable only for abstract
								methods.</p>
							<h2 id="file"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="file">3. Functional Interface Vs Lambda Expressions:
							</h2>

							Once we write Lambda expressions to invoke it's functionality, then Functional Interface is
							required. <br>
							We can use Functional Interface reference to refer Lambda Expression.<br>
							Where ever Functional Interface concept is applicable there we can use Lambda Expressions

							<hr>
							Ex:1 Without Lambda Expression
							<pre>1) interface Interf { 
2) public void methodOne();} 

3) public class Demo implements Interf { 
4) public void methodOne() { 
5) System.out.println("method one execution"); 
6) } }
7) public class Test { 
8) public static void main(String[] args) { 
9) Interf i = new Demo(); 
10) i.methodOne(); 
11) } 
12) }
<!-- No compile time error
Compile time Error -->
</pre>

							Above code With Lambda expression
							<pre>1) interface Interf { 
2) public void methodOne(); } 

3) class Test { 
4) public static void main(String[] args) { 
5) Interf i = () -&gt; System.out.println("method one execution"); 
6) i.methodOne(); 
7) } 
8) }
</pre>
							<hr>

							Ex 2: Without Lambda Expression
							<pre>1) interface Interf { 
2) public void sum(inta,int b); 
3) } 

4) class Demo implements Interf { 
5) public void sum(inta,int b) { 
6) System.out.println("The sum:"+(a+b)); 
7) } 
8) } 

9) public class Test { 
10) public static void main(String[] args) { 
11) Interf i = new Demo(); 
12) i.sum(20,5); 
13) } 
14) }
</pre>
							Above code With Lambda Expression
							<pre>1) interface Interf { 
2) public void sum(inta, int b); 
3) } 

4) class Test { 
5) public static void main(String[] args) { 
6) Interf i = (a,b) -&gt; System.out.println("The Sum:" +(a+b)); 
7) i.sum(5,10); 
8) } 
9) }
</pre>
							<hr>
							Ex 3: Without Lambda Expressions
							<pre>1) interface Interf { 
2) public int square(int x); 
3) } 

4) class Demo implements Interf { 
5) public int square(int x) { 
6) return x*x; // OR (int x) -&gt; x*x ;
7) } 
8) } 

9) class Test { 
10) public static void main(String[] args) { 
11) Interf i = new Demo(); 
12) System.out.println("The Square of 7 is: " +i.square(7)); 
13) } 
14) }
</pre>
							Above code with Lambda Expression
							<pre>1) interface Interf { 
2) public int square(int x); 
3) } 

4) class Test { 
5) public static void main(String[] args) { 
6) Interf i = x -&gt; x*x; 
7) System.out.println("The Square of 5 is:"+i.square(5)); 
8) } 
9) }
</pre>
							<hr>
							Ex 4: Without Lambda expression
							<pre>1) class MyRunnable implements Runnable { 
2) public void run() { 
3) for(int i=0; i&lt;10; i++) { 
4) System.out.println("Child Thread"); 
5) } 
6) } 
7) } 

8) class ThreadDemo { 
9) public static void main(String[] args) { 
10) Runnable r = new myRunnable(); 
11) Thread t = new Thread(r); 
12) t.start(); 
13) for(int i=0; i&lt;10; i++) { 
14) System.out.println("Main Thread") 
15) } 
16) }
17) }
</pre>

							With Lambda expression
							<pre>1) class ThreadDemo { 
2) public static void main(String[] args) { 
3) Runnable r = () -&gt; { 
4) for(int i=0; i&lt;10; i++) { 
5) System.out.println("Child Thread"); 
6) } 
7) }; 
8) Thread t = new Thread(r); 
9) t.start(); 
10) for(i=0; i&lt;10; i++) { 
11) System.out.println("Main Thread"); 
12) } 
13) } 
14) }
</pre>
							<h2 id="anonymous"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="anonymous">4. Anonymous inner classes vs Lambda Expressions :
							</h2>

							Wherever we are using anonymous inner classes there may be a chance of using Lambda
							expression to reduce length of the code and to resolve complexity.

							<br>
							Ex: With anonymous inner class

							<pre>1) class Test { 
2) public static void main(String[] args) { 
3) Thread t = new Thread(new Runnable() { 
4) public void run() { 
5) for(int i=0; i&lt;10; i++) { 
6) System.out.println("Child Thread"); 
7) } 
8) } 
9) }); 
10) t.start(); 
11) for(int i=0; i&lt;10; i++) 
12) System.out.println("Main thread"); 
13) } 
14) }
</pre>

							With Lambda expression
							<pre>1) class Test { 
2) public static void main(String[] args) { 
3) Thread t = new Thread(() -&gt; { 
4) for(int i=0; i&lt;10; i++) { 
5) System.out.println("Child Thread"); 
6) } 
7) }); 
8) t.start(); 
9) for(int i=0; i&lt;10; i++) { 
10) System.out.println("Main Thread"); 
11) } 
12) } 
13) }
</pre>

							<strong>What are the advantages of Lambda expression ?</strong>
							<ul>
								<li>We can reduce length of the code so that readability of the code will be improved.
								</li>
								<li>We can resolve complexity of anonymous inner classes.
								</li>
								<li>We can provide Lambda expression in the place of object.
								</li>
								<li>We can pass lambda expression as argument to methods.
								</li>
							</ul>
							Note:
							<ul>
								<li>Anonymous inner class can extend concrete class, can extend abstract class, can
									implement interface with any number of methods but
									Lambda expression can implement an interface with only single abstract method
									(Functional Interface).
								</li>
								<li>Hence if anonymous inner class implements Functional Interface in that particular
									case only we can replace with lambda expressions. Hence wherever anonymous inner
									class concept is there, it may not possible to replace with Lambda expressions.
								</li>
								<li>Anonymous inner class! = Lambda Expression
								</li>
								<li>Inside anonymous inner class we can declare instance variables.
								</li>
								<li>Inside anonymous inner class "this" always refers current inner class
									object(anonymous inner class) but not related outer class object
								</li>
							</ul>
							Ex:
							<ul>
								<li>Inside lambda expression we can't declare instance variables.
								</li>
								<li>Whatever the variables declare inside lambda expression are simply acts as local
									variables
								</li>
								<li>Within lambda expression "this" keyword represents current outer class object
									reference (that is current enclosing class reference in which we declare lambda
									expression)
								</li>
							</ul>
							<pre>Ex: 
1) interface Interf { 
2) public void m1(); 
3) } 
4) class Test { 
5) int x = 777; 
6) public void m2() { 
7) Interf i = ()-&gt; { 
8) int x = 888; 
9) System.out.println(x); //888 
10) System.out.println(this.x); //777 
11) }; 
12) i.m1(); 
13) } 
14) public static void main(String[] args) { 
15) Test t = new Test(); 
16) t.m2(); 
17) } 
18) }
</pre>
							<ul>
								<li> From lambda expression we can access enclosing class variables and enclosing method
									variables directly.
								</li>
								<li> The local variables referenced from lambda expression are implicitly final and
									hence we can't perform re-assignment for those local variables otherwise we get
									compile time error
								</li>
							</ul>

							<pre>Ex: 
1) interface Interf { 
2) public void m1(); 
3) } 
4) class Test { 
5) int x = 10; 
6) public void m2() { 
7) int y = 20; 
8) Interf i = () -&gt; { 
9) System.out.println(x); //10 
10) System.out.println(y); //20 
11) x = 888; 
12) y = 999; //CE 
13) }; 
14) i.m1(); 
15) y = 777; 
16) } 
17) public static void main(String[] args) { 
18) Test t = new Test(); 
19) t.m2();
20) } 
21) }
</pre>



							<br>
							<table border="1">
								<h2>Differences between anonymous inner classes and
									Lambda expression</h2>
								<tbody>
									<tr>
										<th>Anonymous Inner class</th>
										<th>Lambda Expression</th>
									</tr>
									<tr>
										<td>It's a class without name</td>
										<td>It's a method without name (anonymous function)</td>
									</tr>
									<tr>
										<td>Anonymous inner class can extend abstract and concrete classes </td>
										<td>Lambda expression can't extend abstract and concrete classes</td>
									</tr>
									<tr>
										<td>Anonymous inner class can implement an interface that contains any number of
											abstract methods</td>
										<td>Lambda expression can implement an interface which contains single abstract
											method (Functional Interface)</td>
									</tr>
									<tr>
										<td>Inside anonymous inner class we can declare instance variables.</td>
										<td>Inside Lambda expression we can't declare instance variables, whatever the
											variables declared are simply acts as local variables.</td>
									</tr>
									<tr>
										<td>Anonymous inner classes can be instantiated</td>
										<td>Lambda expressions can't be instantiated</td>
									</tr>
									<tr>
										<td>Inside anonymous inner class "this" always refers current anonymous inner
											class object but not outer class Object.</td>
										<td>Inside Lambda expression "this" always refers current outer class object.
											That is enclosing class object.</td>
									</tr>
									<tr>
										<td>Anonymous inner class is the best choice if we want to handle multiple
											methods.</td>
										<td>Lambda expression is the best choice if we want to handle interface with
											single abstract method (Functional Interface).</td>
									</tr>
									<tr>
										<td>In the case of anonymous inner class at the time of compilation a separate
											dot class file will be generated (outerclass$1.class)</td>
										<td>At the time of compilation no dot class file will be generated for Lambda
											expression. It simply converts in to private method outer class.</td>
									</tr>
									<tr>
										<td>Memory allocated on demand whenever we are creating an object</td>
										<td>Reside in permanent memory of JVM (Method Area).</td>
									</tr>
								</tbody>
							</table>
							<h2 id="default"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="default">4. Default Methods</h2>



							<ul>
								<li> Until 1.7 version onwards inside interface we can take only public abstract methods
									and public static final variables (every method present inside interface is always
									public and abstract whether we are declaring or not).
								</li>
								<li> Every variable declared inside interface is always public static final whether we
									are declaring or not.
								</li>
								<li> But from 1.8 version onwards in addition to these, we can declare default concrete
									methods also inside interface, which are also known as defender methods.
								</li>
								<li> We can declare default method with the keyword "default" as follows
									<pre>1) default void m1(){ 
2) System.out.println ("Default Method"); 
3) }
</pre>
								</li>
								<li> Interface default methods are by-default available to all implementation classes.
									Based on requirement implementation class can use these default methods directly or
									can override.
								</li>
							</ul>
							<pre>Ex: 
1) interface Interf { 
2) default void m1() { 
3) System.out.println("Default Method"); 
4) } 
5) } 
6) class Test implements Interf { 
7) public static void main(String[] args) { 
8) Test t = new Test(); 
9) t.m1(); 
10) } 
11) }
</pre>
							<ul>
								<li> Default methods also known as defender methods or virtual extension methods.
								</li>
								<li> The main advantage of default methods is without effecting implementation classes
									we can add new functionality to the interface (backward compatibility).
								</li>
							</ul>
							Note: We can't override object class methods as default methods inside interface otherwise
							we get compile time error.

							<pre>Ex: 
1) interface Interf { 
2) default int hashCode() { 
3) return 10; 
4) } 
5) }
</pre>
							CompileTimeError
							<p>
								<strong>Reason:</strong> Object class methods are by-default available to every Java
								class hence it's not required to bring through default methods.
							</p>

							<h4>Default method vs multiple inheritance</h4>
							Two interfaces can contain default method with same signature then there may be a chance of
							ambiguity problem (diamond problem) to the implementation class.
							To overcome this problem compulsory we should override default method in the implementation
							class otherwise we get compile time error.
							<pre>1) Eg 1: 
2) interface Left { 
3) default void m1() { 
4) System.out.println("Left Default Method"); 
5) } 
6) } 
7) 

8) Eg 2: 
9) interface Right { 
10) default void m1() { 
11) System.out.println("Right Default Method"); 
12) } 
13) } 
14) 
15) 

Eg 3: 
16) class Test implements Left, Right {}
</pre>


							<h4>How to override default method in the implementation class ? </h4>

							In the implementation class we can provide complete new implementation or we can call any
							interface method as follows.
							<pre>interfacename.super.m1();
</pre>
							<pre>Ex: 
1) class Test implements Left, Right { 
2) public void m1() { 
3) System.out.println("Test Class Method"); // OR Left.super.m1(); 
4) } 
5) public static void main(String[] args) { 
6) Test t = new Test(); 
7) t.m1(); 
8) } 
9) }
</pre>

							<h4>Differences between interface with default methods and abstract class</h4>
							<p>
								Even though we can add concrete methods in the form of default methods to the interface,
								it won't be equal to abstract class.</p>

							<table border="1">
								<tbody>
									<tr>
										<th>Interface with Default Methods</th>
										<th>Abstract Class</th>
									</tr>
									<tr>
										<td>Inside interface every variable is always public static final and there is
											no chance of instance variables</td>
										<td>Inside abstract class there may be a chance of instance variables which are
											required to the child class.</td>
									</tr>
									<tr>
										<td>Interface never talks about state of Object.</td>
										<td>Abstract class can talk about state of Object.</td>
									</tr>
									<tr>
										<td>Inside interface we can't declare constructors.</td>
										<td>Inside abstract class we can declare constructors.</td>
									</tr>
									<tr>
										<td>Inside interface we can't declare instance and static blocks.</td>
										<td>Inside abstract class we can declare instance and static blocks.</td>
									</tr>
									<tr>
										<td>Functional interface with default methods can refer lambda expression.</td>
										<td>Abstract class can't refer lambda Expressions.</td>
									</tr>
									<tr>
										<td>Inside interface we can't override Object class methods.</td>
										<td>Inside abstract class we can override Object class methods.</td>
									</tr>
								</tbody>
							</table>
							<h2 id="static"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="static">6. Static methods inside interface:</h2>


							<ul>
								<li> From 1.8 version onwards in addition to default methods we can write static methods
									also inside interface to define utility functions.
								</li>
								<li> Interface static methods by-default not available to the implementation classes
									hence by using implementation class reference we can't call interface static
									methods. We should call interface static methods by using interface name.
								</li>
							</ul>
							<pre>Ex: 
1) interface Interf { 
2) public static void sum(int a, int b) { 
3) System.out.println("The Sum:"+(a+b)); 
4) } 
5) } 
6) class Test implements Interf { 
7) public static void main(String[] args) { 
8) Test t = new Test(); 
9) t.sum(10, 20); //CE 
10) Test.sum(10, 20); //CE 
11) Interf.sum(10, 20); 
12) } 
13) }
</pre>
							<ul>
								<li> As interface static methods by default not available to the implementation class,
									overriding concept is not applicable.
								</li>
								<li> Based on our requirement we can define exactly same method in the implementation
									class, it's valid but not overriding.
								</li>
							</ul>
							<pre>Ex:1 
1) interface Interf { 
2) public static void m1() {} 
3) } 
4) class Test implements Interf { 
5) public static void m1() {} 
6) }
</pre>
							It's valid but not overriding

							<pre>Ex:2 
1) interface Interf { 
2) public static void m1() {} 
3) }
4) class Test implements Interf { 
5) public void m1() {} 
6) }
</pre>
							This's valid but not overriding

							<pre>Ex3: 
1) class P { 
2) private void m1() {} 
3) } 
4) class C extends P { 
5) public void m1() {} 
6) }
</pre>
							This's valid but not overriding
							<br>
							From 1.8 version onwards we can write main() method inside interface and hence we can run
							interface directly from the command prompt.
							<pre>Ex: 
1) interface Interf { 
2) public static void main(String[] args) { 
3) System.out.println("Interface Main Method"); 
4) } 
5) }
</pre>
							At the command prompt:
							<pre>javac Interf.Java
java Interf
</pre>

							<h2 id="predicate"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="predicate">7. Predicate:</h2>
							<ul>
								<li> A predicate is a function with a single argument and returns boolean value.
								</li>
								<li> To implement predicate functions in Java, Oracle people introduced Predicate
									interface in 1.8 version (i.e.,Predicate&lt;T&gt;).
								</li>
								<li> Predicate interface present in Java.util.function package.
								</li>
								<li> It's a functional interface and it contains only one method i.e., test()
								</li>
							</ul>

							<pre>Ex:
interface Predicate&lt;T&gt; {
public boolean test(T t);
}
</pre>
							As predicate is a functional interface and hence it can refers lambda expression<br>
							Ex:1 Write a predicate to check whether the given integer is greater than 10 or not.
							<pre>Ex:
public boolean test(Integer I) { 
if (I &gt;10) {
return true;
} else {
return false;
} 
}

(Integer I) -&gt; {
if(I &gt; 10)
return true;
else
return false;
}

I -&gt; (I&gt;10);
Predicate&lt;Integer&gt; p = I -&gt;(I &gt;10);
System.out.println (p.test(100)); //true
System.out.println (p.test(7)); //false
</pre>
							Program:
							<pre>1) import java.util.function; 
2) class Test { 
3) public static void main(String[] args) { 
4) Predicate&lt;Integer&gt; p = I -&gt; (i&gt;10); 
5) System.out.println(p.test(100)); 
6) System.out.println(p.test(7)); 
7) System.out.println(p.test(true)); //CE 
8) } 
9) }
</pre>

							# 1 Write a predicate to check the length of given string is greater than 3 or not.

							<pre>Predicate&lt;String&gt; p = s -&gt; (s.length() &gt; 3);
System.out.println (p.test("rvkb")); //true
System.out.println (p.test("rk")); //false
</pre>

							#-2 write a predicate to check whether the given collection is empty or not.
							<pre>Predicate<collection> p = c -&gt; c.isEmpty();
</collection></pre>

							Predicate joining
							<br>
							It's possible to join predicates into a single predicate by using the following methods.
							<ul>
								<li>and() </li>
								<li>or() </li>
								<li>negate() </li>
							</ul>
							these are exactly same as logical AND ,OR complement operators

							<pre>Ex: 
1) import java.util.function.*; 
2) class test { 
3) public static void main(string[] args) { 
4) int[] x = {0, 5, 10, 15, 20, 25, 30}; 
5) Predicate&lt;Integer&gt; p1 = i-&gt;i&gt;10; 
6) Predicate&lt;Integer&gt; p2=i -&gt; i%2==0; 
7) System.out.println("The Numbers Greater Than 10:"); 
8) m1(p1, x); 
9) System.out.println("The Even Numbers Are:");
10) m1(p2, x); 
11) System.out.println("The Numbers Not Greater Than 10:"); 
12) m1(p1.negate(), x); 
13) System.out.println("The Numbers Greater Than 10 And Even Are:"); 
14) m1(p1.and(p2), x); 
15) System.out.println("The Numbers Greater Than 10 OR Even:"); 
16) m1(p1.or(p2), x); 
17) } 
18) public static void m1(Predicate&lt;Integer&gt; p, int[] x) { 
19) for(int x1:x) { 
20) if(p.test(x1)) 
21) System.out.println(x1); 
22) } 
23) } 
24) }
</pre>

							<h2 id="functions"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="functions">8. Functions:</h2>
							<ul>
								<li> Functions are exactly same as predicates except that functions can return any type
									of result but function should (can) return only one value and that value can be any
									type as per our requirement.
								</li>
								<li> To implement functions oracle people introduced Function interface in 1.8version.
								</li>
								<li> Function interface present in java.util.function package.
								</li>
								<li> Function interface contains only one method i.e., apply()
								</li>
							</ul>
							<pre>interface Function(T,R) {
public R apply(T t);
}
</pre>
							Assignment: Write a function to find length of given input string.
							<pre>Ex: 
1) import java.util.function.*; 
2) class Test { 
3) public static void main(String[] args) { 
4) Function&lt;String, Integer&gt; f = s -&gt;s.length(); 
5) System.out.println(f.apply("Times")); 
6) System.out.println(f.apply("Soft")); 
7) } 
8) }
</pre>
							Note: Function is a functional interface and hence it can refer lambda expression.
							<br><br>
							<table border="1">
								<caption style="font-size: x-large;">Differences between Predicate and Function
								</caption>
								<tbody>
									<tr>
										<th>Predicate</th>
										<th>Function</th>
									</tr>
									<tr>
										<td>To implement conditional checks we should go for predicate</td>
										<td>To perform certain operation and to return some result we should go for
											function.</td>
									</tr>
									<tr>
										<td>Predicate can take one type parameter which represents input argument type.
											Predicate&lt;T&gt;</td>
										<td>Function can take 2 type parameters. First one represent input argument type
											and Second one represent return Type.
											Function&lt;T,R&gt;</td>
									</tr>
									<tr>
										<td>Predicate interface defines only one method called <strong>test()</strong>
										</td>
										<td>Function interface defines only one Method called <strong>apply()</strong>.
										</td>
									</tr>
									<tr>
										<td>public boolean test(T t)</td>
										<td>public R apply(T t)</td>
									</tr>
									<tr>
										<td>Predicate can return only boolean value.</td>
										<td>Function can return any type of value</td>
									</tr>
									<!-- <tr><td></td><td></td></tr> -->
								</tbody>
							</table>
							<br>
							<p>Note: Predicate is a boolean valued function and(), or(), negate() are default methods,
								present inside Predicate interface.</p>

							<h2 id="consumer"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="consumer">9. Consumer</h2>
							<h2 id="supplier"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="supplier">10. Supplier</h2>

							<h2 id="double-colon"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="double-colon">11. MethodReferences</h2>
							<ul>
								<li> Functional Interface method can be mapped to our specified method by using ::
									(double colon) operator. This is called method reference.
								</li>
								<li> Our specified method can be either static method or instance method.
								</li>
								<li> Functional Interface method and our specified method should have same argument
									types, except this the remaining things like
									returntype, methodname, modifiers etc are not required to match.
								</li>
							</ul>

							Syntax:
							<ul>
								<li>if our specified method is static method <strong> Classname::methodName </strong>
								</li>
								<li>if the method is instance method <strong>Objref::methodName</strong>
								</li>
							</ul>
							<p>Functional Interface can refer lambda expression and Functional Interface can also refer
								method reference. Hence lambda expression can be replaced with method reference. Hence
								method reference is alternative syntax to lambda expression.
							</p>
							Ex: With Lambda Expression
							<pre>1) class Test { 
2) public static void main(String[] args) { 
3) Runnable r = () -&gt; { 
4) for(int i=0; i&lt;=10; i++) { 
5) System.out.println("Child Thread"); 
6) } 
7) }; 
8) Thread t = new Thread(r); 
9) t.start(); 
10) for(int i=0; i&lt;=10; i++) { 
11) System.out.println("Main Thread"); 
12) } 
13) } 
14) }
</pre>
							With Method Reference
							<pre>1) class Test { 
2) public static void m1() { 
3) for(int i=0; i&lt;=10; i++) { 
4) System.out.println("Child Thread"); 
5) }
6) } 
7) public static void main(String[] args) { 
8) Runnable r = Test:: m1; 
9) Thread t = new Thread(r); 
10) t.start(); 
11) for(int i=0; i&lt;=10; i++) { 
12) System.out.println("Main Thread"); 
13) } 
14) }
</pre>
							In the above example Runnable interface run() method referring to Test class static method
							m1().

							<h4>Method reference to Instance method:</h4>
							<pre>Ex: 
1) interface Interf { 
2) public void m1(int i); 
3) } 
4) class Test { 
5) public void m2(int i) { 
6) System.out.println("From Method Reference:"+i); 
7) } 
8) public static void main(String[] args) { 
9) Interf f = I -&gt;sop("From Lambda Expression:"+i); 
10) f.m1(10); 11) Test t = new Test(); 
12) Interf i1 = t::m2; 
13) i1.m1(20); 
14) } 
15) }
</pre>
							In the above example functional interface method m1() referring to Test class instance
							method m2().<br>
							The main advantage of method reference is we can use already existing code to implement
							functional interfaces (code reusability).
							<h4>Constructor References</h4>
							We can use :: ( double colon )operator to refer constructors also
							Syntax: classname :: new
							<pre>Ex:
Interf f = sample :: new;
</pre>
							functional interface f referring sample class constructor

							<pre>Ex: 
1) class Sample { 
2) private String s; 
3) Sample(String s) { 
4) this.s = s; 
5) System.out.println("Constructor Executed:"+s); 
6) } 
7) } 
8) interface Interf { 
9) public Sample get(String s); 
10) } 
11) class Test { 
12) public static void main(String[] args) { 
13) Interf f = s -&gt; new Sample(s); 
14) f.get("From Lambda Expression"); 
15) Interf f1 = Sample :: new; 
16) f1.get("From Constructor Reference"); 
17) } 
18) }
</pre>
							<p>Note: In method and constructor references compulsory the argument types must be matched.
							</p>
							<h2 id="stream-api"><br><br><br></h2>
							<h2 class="mainbreadcrumb" id="stream-api">12. Streams API</h2>

							To process objects of the collection, in 1.8 version Streams concept introduced.
							<h3>What is the differences between java.util.stream and java.io streams ?</h3>
							<ul>
								<li>java.util streams meant for processing objects from the
									collection. i.e, it represents a stream of objects from the
									collection</li>
								<li>but java.io streams meant for processing binary and
									character data with respect to file. i.e., it represents stream of
									binary data or character data from the file. <br>hence java.io streams
									and java.util streams both are different.</li>
							</ul>


							<h3>What is the difference between collection and stream ?</h3>
							<ul>
								<li> If we want to represent a group of individual objects as a single entity then we
									should go for collection.</li>
								<li> If we want to process a group of objects from the collection then we should go for
									streams.</li>
								<li> We can create a stream object to the collection by using stream() method of
									Collection interface. </li>
								<li>stream() method is a default method added to the Collection in 1.8 version.
									<pre>default Stream stream()
Ex: 
Stream s = c.stream();
</pre>
								</li>
							</ul>

							<ul>
								<li> Stream is an interface present in java.util.stream. Once we got the stream, by
									using that we can process objects of that collection.
								</li>
								<li> We can process the objects in the following 2 phases
									<ol>
										<li>Configuration</li>
										<li>Processing</li>
									</ol>
								</li>
							</ul>
							<hr>
							<h3>1) Configuration:</h3>
							We can configure either by using filter mechanism or by using map mechanism.

							<h4>Filtering:</h4>
							<ul>
								<li>We can configure a filter to filter elements from the collection based on some
									boolean condition by using filter() method of Stream interface.</li>
							</ul>
							<pre>	public Stream filter(Predicate&lt;T&gt; t)
		here (Predicate&lt;T &gt; t ) can be a boolean valued function/lambda expression
</pre>
							<pre>Ex:
Stream s = c.stream();
Stream s1 = s.filter(i -&gt; i%2==0);
</pre>
							Hence to filter elements of collection based on some Boolean condition we should go for
							filter() method.

							<h4>Mapping:</h4>
							<ul>
								<li>If we want to create a separate new object, for every object present in the
									collection based on our requirement then we should go for map() method of Stream
									interface.</li>
							</ul>
							<pre>public Stream map (Function f);
			It can be lambda expression also
</pre>

							<pre>Ex:
Stream s = c.stream();
Stream s1 = s.map(i-&gt; i+10);
</pre>
							Once we performed configuration we can process objects by using several methods.
							<hr>
							<h3>2) Processing</h3>
							<ul>
								<li>processing by collect() method</li>
								<li>Processing by count() method</li>
								<li>Processing by sorted() method</li>
								<li>Processing by min() and max() methods</li>
								<li>forEach() method</li>
								<li>toArray() method</li>
								<li>Stream.of()method</li>
							</ul>


							<h4>I. Processing by collect() method</h4>
							This method collects the elements from the stream and adding to the specified to the
							collection indicated (specified) by argument.
							<br>
							<br>
							Ex 1: To collect only even numbers from the array list
							<br><br>
							Approach-1: Without Streams
							<pre>1) import java.util.*; 
2) class Test { 
3) public static void main(String[] args) { 
4) ArrayList&lt;Integer&gt; l1 = new ArrayList&lt;Integer&gt;(); 
5) for(int i=0; i&lt;=10; i++) { 
6) l1.add(i); 
7) } 
8) System.out.println(l1); 
9) ArrayList&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); 
10) for(Integer i:l1) { 
11) if(i%2 == 0) 
12) l2.add(i); 
13) } 
14) System.out.println(l2); 
15) } 
16) }
</pre>

							Approach-2: With Streams

							<pre>1) import java.util.*; 
2) import java.util.stream.*; 
3) class Test { 
4) public static void main(String[] args) { 
5) ArrayList&lt;Integer&gt; l1 = new ArrayList&lt;Integer&gt;(); 
6) for(inti=0; i&lt;=10; i++) { 
7) l1.add(i); 
8) } 
9) System.out.println(l1); 
10) List&lt;Integer&gt; l2 = l1.stream().filter(i -&gt; i%2==0).collect(Collectors.toList()); 
11) System.out.println(l2); 
12) } 
13) }
</pre>


							Ex:
							Program for map() and collect() Method
							<pre>1) import java.util.*; 
2) import java.util.stream.*; 
3) class Test { 
4) public static void main(String[] args) { 
5) ArrayList&lt;String&gt; l = new ArrayList&lt;String&gt;(); 
6) l.add("rvk"); l.add("rk"); l.add("rkv"); l.add("rvki"); l.add("rvkir"); 
7) System.out.println(l); 
8) List&lt;String&gt; l2 = l.stream().map(s -&gt;s.toUpperCase()).collect(Collectors.toList()); 
9) System.out.println(l2); 
10) } 
11) }
</pre>

							<h4>II. Processing by count() method</h4>

							This method returns number of elements present in the stream. <br>
							<em>public long count()</em>

							<pre>Ex:
long count = l.stream().filter(s -&gt;s.length()==5).count();
sop("The number of 5 length strings is:"+count);
</pre>

							<h4>III. Processing by sorted() method</h4>
							<ul>
								<li>If we sort the elements present inside stream then we should go for sorted() method.
								</li>
								<li>the sorting can either default natural sorting order or customized sorting order
									specified by comparator.</li>
							</ul>
							<pre>sorted()- default natural sorting order
sorted(Comparator c)-customized sorting order.
</pre>

							<pre>Ex:
List&lt;String&gt; l3=l.stream().sorted().collect(Collectors.toList());
sop("according to default natural sorting order:"+l3);

List&lt;String&gt; l4=l.stream().sorted((s1,s2) -&gt; -s1.compareTo(s2)).collect(Collectors.toList());
sop("according to customized sorting order:"+l4);
</pre>

							<h4>IV. Processing by min() and max() methods</h4>
							<pre>min(Comparator c)
returns minimum value according to specified comparator.

max(Comparator c)
returns maximum value according to specified comparator
</pre>
							<pre>Ex:
String min=l.stream().min((s1,s2) -&gt; s1.compareTo(s2)).get();

sop("minimum value is:"+min);

String max=l.stream().max((s1,s2) -&gt; s1.compareTo(s2)).get();

sop("maximum value is:"+max);
</pre>

							<h4>V. forEach() method</h4>
							<ul>
								<li>This method will not return anything.</li>
								<li>This method will take lambda expression as argument and apply that lambda expression
									for each element present in the stream.</li>
							</ul>

							<pre>Ex:
l.stream().forEach(s-&gt;sop(s));
l3.stream().forEach(System.out:: println);
</pre>

							<pre>Ex: 
1) import java.util.*; 
2) import java.util.stream.*; 
3) class Test1 { 
4) public static void main(String[] args) { 
5) ArrayList&lt;Integer&gt; l1 = new ArrayaList&lt;Integer&gt;(); 
6) l1.add(0); l1.add(15); l1.add(10); l1.add(5); l1.add(30); l1.add(25); l1.add(20); 
7) System.out.println(l1); 
8) ArrayList&lt;Integer&gt; l2=l1.stream().map(i-&gt; i+10).collect(Collectors.toList()); 
9) System.out.println(l2); 
10) long count = l1.stream().filter(i-&gt;i%2==0).count(); 
11) System.out.println(count); 
12) List&lt;Integer&gt; l3=l1.stream().sorted().collect(Collectors.toList()); 
13) System.out.println(l3); 
14) Comparator&lt;Integer&gt; comp=(i1,i2)-&gt;i1.compareTo(i2); 
15) List&lt;Integer&gt; l4=l1.stream().sorted(comp).collect(Collectors.toList()); 
16) System.out.println(l4); 
17) Integer min=l1.stream().min(comp).get(); 
18) System.out.println(min); 
19) Integer max=l1.stream().max(comp).get(); 
20) System.out.println(max);
21) l3.stream().forEach(i-&gt;sop(i)); 
22) l3.stream().forEach(System.out:: println); 
23) 
24) } 
25) }
</pre>

							<h4>VI. toArray() method</h4>
							We can use toArray() method to copy elements present in the stream into specified array
							<pre>Integer[] ir = l1.stream().toArray(Integer[] :: new);
for(Integer i: ir) {
sop(i);
}
</pre>

							<h4>VII. Stream.of()method</h4>
							We can also apply a stream for group of values and for arrays.
							<pre>Ex:
Stream s=Stream.of(99,999,9999,99999);
s.forEach(System.out:: println);
Double[] d={10.0,10.1,10.2,10.3};
Stream s1=Stream.of(d);
s1.forEach(System.out :: println);
</pre>

							<<h2 id="joda-time"><br><br><br></h2>
								<h2 class="mainbreadcrumb" id="joda-time">13. Date and Time API: (Joda-Time API)</h2>
								<ul>
									<li>Until Java 1.7version the classes present in java.util package to handle Date
										and
										Time (like Date, Calendar, TimeZoneetc) are not up to the mark with respect to
										convenience and performance.</li>
									<li>To overcome this problem in the 1.8version oracle people introduced Joda-Time
										API.
										This API developed by joda.org and available in Java in the form of java.time
										package.</li>
								</ul>
								# program for to display System Date and time.
								<pre>1) import java.time.*; 
2) public class DateTime { 
3) public static void main(String[] args) { 
4) LocalDate date = LocalDate.now(); 
5) System.out.println(date); 
6) LocalTime time=LocalTime.now(); 
7) System.out.println(time); 
8) } 
9) }
O/p:
2015-11-23
12:39:26:587
</pre>

								Once we get LocalDate object we can call the following methods on that object to
								retrieve
								Day,month and year values separately.
								<pre>Ex: 
1) import java.time.*; 
2) class Test { 
3) public static void main(String[] args) { 
4) LocalDate date = LocalDate.now(); 
5) System.out.println(date); 
6) int dd = date.getDayOfMonth(); 
7) int mm = date.getMonthValue(); 
8) int yy = date.getYear(); 
9) System.out.println(dd+"..."+mm+"..."+yy); 
10) System.out.printf("\n%d-%d-%d",dd,mm,yy); 
11) } 
12) }
</pre>

								Once we get LocalTime object we can call the following methods on that object.

								<pre>Ex: 
1) import java.time.*; 
2) class Test { 
3) public static void main(String[] args) { 
4) LocalTime time = LocalTime.now(); 
5) int h = time.getHour(); 
6) int m = time.getMinute(); 
7) int s = time.getSecond(); 
8) int n = time.getNano(); 
9) System.out.printf("\n%d:%d:%d:%d",h,m,s,n); 
10) } 
11) }
</pre>

								If we want to represent both Date and Time then we should go for LocalDateTime object.
								<pre>LocalDateTime dt = LocalDateTime.now(); 
System.out.println(dt);
O/p: 2015-11-23T12:57:24.531
</pre>

								We can represent a particular Date and Time by using LocalDateTime object as follows.
								<pre>Ex:
LocalDateTime dt1 = LocalDateTime.of(1995,Month.APRIL,28,12,45);
sop(dt1);
</pre>

								<pre>Ex:
LocalDateTime dt1=LocalDateTime.of(1995,04,28,12,45);
Sop(dt1);
Sop("After six months:"+dt.plusMonths(6));
Sop("Before six months:"+dt.minusMonths(6));
</pre>

								To Represent Zone:
								ZoneId object can be used to represent Zone.
								<pre>Ex: 
1) import java.time.*; 
2) class ProgramOne { 
3) public static void main(String[] args) { 
4) ZoneId zone = ZoneId.systemDefault(); 
5) System.out.println(zone); 
6) } 
7) }
</pre>

								We can create ZoneId for a particular zone as follows
								<pre>Ex:
ZoneId la = ZoneId.of("America/Los_Angeles");
ZonedDateTime zt = ZonedDateTime.now(la);
System.out.println(zt);
</pre>

								Period Object:
								Period object can be used to represent quantity of time

								<pre>Ex:
LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(1989,06,15);
Period p = Period.between(birthday,today);
System.out.printf("age is %d year %d months %d days",p.getYears(),p.getMonths(),p.getDays());
</pre>

								# write a program to check the given year is leap year or not
								<pre>1) import java.time.*; 
2) public class Leapyear { 
3) int n = Integer.parseInt(args[0]); 
4) Year y = Year.of(n); 
5) if(y.isLeap()) 
6) System.out.printf("%d is Leap year",n); 
7) else 
8) System.out.printf("%d is not Leap year",n); 
9) }
</pre>
								<h2 id="lambda"><br><br><br></h2>
								<h2 class="mainbreadcrumb" id="lambda">14. Type Annotations : </h2>

								<h2 id="lambda"><br><br><br></h2>
								<h2 class="mainbreadcrumb" id="lambda">15. Nashorn JavaScript Engine : </h2>

								<h2 id="lambda"><br><br><br></h2>
								<h2 class="mainbreadcrumb" id="lambda">16. Concurrent Accumulators : </h2>

								<h2 id="lambda"><br><br><br></h2>
								<h2 class="mainbreadcrumb" id="lambda">17. Parallel operations : </h2>

								<h2 id="lambda"><br><br><br></h2>
								<h2 class="mainbreadcrumb" id="lambda">18. PermGen Space Removed : </h2>

								<h2 id="lambda"><br><br><br></h2>
								<h2 class="mainbreadcrumb" id="lambda">19. TLS SNI : </h2>
						</div>
					</div>
					<div class="card-footer">
						<ul class="pagination justify-content-center mb-4">
							<li class="page-item"><a class="page-link btn-outline-primary"
									href="java-internationalization.html">&lArr; Previous</a></li>
							<li class="page-item"><a class="page-link" href="java-interview-questions.html">Next
									&rArr;</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>

	<style>
		.footerfont {
			font-size: 16px
		}
	</style>
	<div class="footer footerfont" style="background: #55585a;">
		<div class="footer-copyright border-top ">
			<div class="container">
				<div class="row">
					<div class="col-sm-6 center py-3 text-white">
						Copyright  2023, <br>The content is copyrighted to Ravi Kalyan Kolloju.
					</div>
				</div>
			</div>
		</div>
	</div>
</body>

</html>